<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Changjie&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-26T07:37:54.020Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>changjie</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式-责任链模式</title>
    <link href="http://yoursite.com/2018/10/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/10/26/设计模式-责任链模式/</id>
    <published>2018-10-26T07:30:00.000Z</published>
    <updated>2018-10-26T07:37:54.020Z</updated>
    
    <content type="html"><![CDATA[<p>责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。比如流程审批就是一个很好的例子，只要终端用户提交申请，根据申请的内容信息，自动建立一条责任链，然后就可以开始流转了<br><a id="more"></a></p><h3 id="定义抽象处理对象"><a href="#定义抽象处理对象" class="headerlink" title="定义抽象处理对象"></a>定义抽象处理对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHander</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下一个节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> AbstractHander nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 本节点的处理方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> days</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> days)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给本节点设置后继节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nextHandler</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextHandler</span><span class="params">(AbstractHander nextHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义具体处理对象"><a href="#定义具体处理对象" class="headerlink" title="定义具体处理对象"></a>定义具体处理对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerA</span> <span class="keyword">extends</span> <span class="title">AbstractHander</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> days)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(days &lt; <span class="number">5</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"**条件符合，由A自己处理这个请求"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"##条件不符合，由A转发这个请求到下一个处理者"</span>);</span><br><span class="line">            <span class="keyword">if</span>(nextHandler != <span class="keyword">null</span>)&#123;</span><br><span class="line">                nextHandler.handle(days);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerB</span> <span class="keyword">extends</span> <span class="title">AbstractHander</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> days)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(days &lt; <span class="number">10</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"**条件符合，由B自己处理这个请求"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"##条件不符合，由B转发这个请求到下一个处理者"</span>);</span><br><span class="line">            <span class="keyword">if</span>(nextHandler != <span class="keyword">null</span>)&#123;</span><br><span class="line">                nextHandler.handle(days);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerC</span> <span class="keyword">extends</span> <span class="title">AbstractHander</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">int</span> days)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(days &lt; <span class="number">15</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"**条件符合，由C自己处理这个请求"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"##条件不符合，由C转发这个请求到下一个处理者"</span>);</span><br><span class="line">            <span class="keyword">if</span>(nextHandler != <span class="keyword">null</span>)&#123;</span><br><span class="line">                nextHandler.handle(days);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化责任链</span></span><br><span class="line">    HandlerA handlerA = <span class="keyword">new</span> HandlerA();</span><br><span class="line">    HandlerB handlerB = <span class="keyword">new</span> HandlerB();</span><br><span class="line">    HandlerC handlerC = <span class="keyword">new</span> HandlerC();</span><br><span class="line">    handlerA.setNextHandler(handlerB);</span><br><span class="line">    handlerB.setNextHandler(handlerC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交给链表表头处理</span></span><br><span class="line">    handlerA.handle(<span class="number">13</span>);</span><br><span class="line">&#125;</span><br><span class="line">输出</span><br><span class="line">##条件不符合，由A转发这个请求到下一个处理者</span><br><span class="line">##条件不符合，由B转发这个请求到下一个处理者</span><br><span class="line">**条件符合，由C自己处理这个请求</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。比如流程审批就是一个很好的例子，只要终端用户提交申请，根据申请的内容信息，自动建立一条责任链，然后就可以开始流转了&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式-适配器模式</title>
    <link href="http://yoursite.com/2018/10/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/10/19/设计模式-适配器模式/</id>
    <published>2018-10-19T08:00:00.000Z</published>
    <updated>2018-10-19T08:39:12.672Z</updated>
    
    <content type="html"><![CDATA[<p>适配器模式跟代理模式写法上类似。适配器模式做的就是，有一个接口需要实现，但是我们现成的对象都不满足，需要加一层适配器来进行适配。分为对象适配器模式、类适配器模式<br><a id="more"></a></p><h3 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>; <span class="comment">// 鸭的呱呱叫</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>; <span class="comment">// 飞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"咕咕叫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鸡也会飞哦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectAdapter</span> <span class="keyword">implements</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Cock cock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectAdapter</span><span class="params">(Cock cock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cock = cock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cock.gobble();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cock.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无非是我们需要一只鸭，但是我们只有一只鸡，这个时候就需要定义一个适配器，由这个适配器来充当鸭，但是适配器里面的方法还是由鸡来实现的</p><h3 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAdapter</span> <span class="keyword">extends</span> <span class="title">Cock</span> <span class="keyword">implements</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        gobble();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过继承 适配器自动获得了所需要的大部分方法来实现鸭的方法</p><h3 id="与代理模式区别"><a href="#与代理模式区别" class="headerlink" title="与代理模式区别"></a>与代理模式区别</h3><p>目的不一样，代理模式做的是增强原方法的活；适配器做的是适配的活，为的是提供“把鸡包装成鸭，然后当做鸭来使用”，而鸡和鸭它们之间原本没有继承关系</p><h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h3><blockquote><p><a href="https://javadoop.com/post/design-pattern#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">Java 设计模式</a>  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;适配器模式跟代理模式写法上类似。适配器模式做的就是，有一个接口需要实现，但是我们现成的对象都不满足，需要加一层适配器来进行适配。分为对象适配器模式、类适配器模式&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式-代理模式</title>
    <link href="http://yoursite.com/2018/10/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/10/19/设计模式-代理模式/</id>
    <published>2018-10-19T08:00:00.000Z</published>
    <updated>2018-11-01T09:53:06.067Z</updated>
    
    <content type="html"><![CDATA[<p>代理模式就是不直接对外提供其实现类，而是提供其代理类，隐藏实现类的细节，通常还用于在真实的实现的前后添加一部分逻辑<br><a id="more"></a></p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>目标接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>委托类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>代理类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理类为了和其实现类功能一样，所以也要实现目标接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//代理对象持有委托类的引用</span></span><br><span class="line">    <span class="keyword">private</span> Subject realSubject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticProxy</span><span class="params">(Subject realSubject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.realSubject = realSubject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"静态代理before"</span>);</span><br><span class="line">        realSubject.hello();</span><br><span class="line">        System.out.println(<span class="string">"静态代理after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject subject = <span class="keyword">new</span> StaticProxy(<span class="keyword">new</span> RealSubject());</span><br><span class="line">        <span class="comment">//调用代理类对象方法</span></span><br><span class="line">        subject.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面这种方式成为静态代理，静态代理的局限在于运行前必须编写好代理类，如果需要被代理多个方法就会有很多冗余代码</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>代理类在程序运行时创建的代理方式被成为 动态代理。 也就是说，这种情况下，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数</p><ol><li>jdk自带的动态代理</li></ol><p>在使用动态代理时，需要定义一个位于代理类与委托类之间的中介类，这个中介类被要求实现InvocationHandler接口<br>由动态代理类委托中间类，中间类持有真正目标类的引用，其实是两层静态代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKDynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中间类持有真正目标类的引用</span></span><br><span class="line">    <span class="keyword">private</span> Object subject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截代理类对象的所有方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理类对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 具体调用的是代理类的哪个方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(proxy.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">"动态代理before"</span>);</span><br><span class="line">        method.invoke(subject, args);<span class="comment">//执行目标类方法</span></span><br><span class="line">        System.out.println(<span class="string">"动态代理before"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//让中间类持有真正目标类的引用</span></span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> JDKDynamicProxy(<span class="keyword">new</span> RealSubject());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建动态代理类实例</span></span><br><span class="line">        Subject subject = (Subject) Proxy.newProxyInstance(</span><br><span class="line">                Thread.currentThread().getContextClassLoader(),<span class="comment">//定义了代理类的ClassLoder</span></span><br><span class="line">                <span class="keyword">new</span> Class[] &#123;Subject.class&#125;,<span class="comment">//代理类实现的接口列表</span></span><br><span class="line">                handler);<span class="comment">//调用处理器</span></span><br><span class="line"></span><br><span class="line">        System.out.println(subject.getClass().getName());</span><br><span class="line">        <span class="comment">//调用代理类实例方法</span></span><br><span class="line">        subject.hello();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">com.sun.proxy.$Proxy0</span><br><span class="line">com.sun.proxy.$Proxy0</span><br><span class="line">动态代理before</span><br><span class="line">hello</span><br><span class="line">动态代理before</span><br></pre></td></tr></table></figure><p>特点：</p><ul><li>类名：格式是“$ProxyN”，其中 N 是一个逐一递增的阿拉伯数字，代表 Proxy 类第 N 次生成的动态代理类，并不是每次调用 Proxy 的静态方法创建动态代理类都会使得 N 值增加，原因是如果对同一组接口（包括接口排列的顺序相同）试图重复创建动态代理类，它会很聪明地返回先前已经创建好的代理类的类对象，而不会再尝试去创建一个全新的代理类，这样可以节省不必要的代码重复生成，提高了代理类的创建效率</li><li>类继承关系：Proxy 类是它的父类，这个规则适用于所有由 Proxy 创建的动态代理类。而且该类还实现了其所代理的一组接口<br><img src="https://img-blog.csdn.net/20170412201807733?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZGFuY2h1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></li></ul><p>缺点：<br>Proxy只能对interface进行代理，无法实现对class的动态代理。观察动态生成的代理继承关系图可知原因，他们已经有一个固定的父类叫做Proxy，Java语法限定其不能再继承其他的父类</p><ol start="2"><li>cglib实现的动态代理<br>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充</li></ol><ul><li>原理：动态生成一个要代理类的子类，子类重写要代理的类的所有不是final的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。它比使用java反射的JDK动态代理要快。</li><li>底层：使用字节码处理框架ASM，来转换字节码并生成新的类。不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。</li><li>缺点：对于final方法，无法进行代理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibDynamicProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">////设置增强类的父类</span></span><br><span class="line">        enhancer.setSuperclass(RealSubject.class);</span><br><span class="line">        <span class="comment">//设置拦截器，拦截对父类所有非final方法的调用</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(o.getClass().getName());</span><br><span class="line">                System.out.println(<span class="string">"cglib动态代理before"</span>);</span><br><span class="line">                <span class="comment">//调用父类方法</span></span><br><span class="line">                methodProxy.invokeSuper(o, objects);</span><br><span class="line">                System.out.println(<span class="string">"cglib动态代理after"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建动态代理对象</span></span><br><span class="line">        Subject subject = (Subject) enhancer.create();</span><br><span class="line">        System.out.println(subject.getClass().getName());</span><br><span class="line"></span><br><span class="line">        subject.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">me.changjie.proxy.RealSubject$$EnhancerByCGLIB$$<span class="number">636</span>b402a</span><br><span class="line">me.changjie.proxy.RealSubject$$EnhancerByCGLIB$$<span class="number">636</span>b402a</span><br><span class="line">cglib动态代理before</span><br><span class="line">hello</span><br><span class="line">cglib动态代理after</span><br></pre></td></tr></table></figure><p>配合过滤器使用可选择性的对方法进行拦截<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibDynamicProxy2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(RealSubject.class);</span><br><span class="line"></span><br><span class="line">        Callback interceptor = <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(o.getClass().getName());</span><br><span class="line">                System.out.println(<span class="string">"cglib动态代理2before"</span>);</span><br><span class="line">                <span class="comment">//调用父类方法</span></span><br><span class="line">                methodProxy.invokeSuper(o, objects);</span><br><span class="line">                System.out.println(<span class="string">"cglib动态代理2after"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//NoOp表示no operator，即什么操作也不做，代理类直接调用被代理的方法不进行拦截</span></span><br><span class="line">        enhancer.setCallbacks(<span class="keyword">new</span> Callback[]&#123;interceptor, NoOp.INSTANCE&#125;);</span><br><span class="line"></span><br><span class="line">        CallbackFilter filter = <span class="keyword">new</span> CallbackFilter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">accept</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">"hello2"</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"我将此方法过滤掉了，不对该方法进行拦截"</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//对应拦截器数组索引，NoOp.INSTANCE</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//对应拦截器数组索引，interceptor</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        enhancer.setCallbackFilter(filter);</span><br><span class="line"></span><br><span class="line">        RealSubject realSubject = (RealSubject) enhancer.create();</span><br><span class="line">        realSubject.hello();</span><br><span class="line">        realSubject.hello2();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">我将此方法过滤掉了，不对该方法进行拦截</span><br><span class="line">me.changjie.proxy.RealSubject$$EnhancerByCGLIB$$afdc3840</span><br><span class="line">cglib动态代理<span class="number">2</span>before</span><br><span class="line">hello</span><br><span class="line">cglib动态代理<span class="number">2</span>after</span><br><span class="line">hello2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代理模式就是不直接对外提供其实现类，而是提供其代理类，隐藏实现类的细节，通常还用于在真实的实现的前后添加一部分逻辑&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-Spring Quartz和Task的区别</title>
    <link href="http://yoursite.com/2018/10/19/Spring-Spring%20Quartz%E5%92%8CTask%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/10/19/Spring-Spring Quartz和Task的区别/</id>
    <published>2018-10-19T06:00:00.000Z</published>
    <updated>2018-10-19T05:54:56.033Z</updated>
    
    <content type="html"><![CDATA[<p>目前比较常用的定时任务解决方案一般就是Spring Quartz和Task</p><h3 id="spring-quartz"><a href="#spring-quartz" class="headerlink" title="spring-quartz"></a>spring-quartz</h3><p>spring-quartz只是spring对quartz的一个包装而已。其实现是在spring-context-support中</p><ol><li>特点</li></ol><ul><li>默认多线程异步执行</li><li>单个任务时，在上一个调度未完成时，下一个调度时间到时，会另起一个线程开始新的调度。业务繁忙时，一个任务会有多个调度，可能导致数据处理异常</li><li>多个任务时，任务之间没有直接影响，多任务执行的快慢取决于CPU的性能<a id="more"></a></li></ul><ol start="2"><li>使用<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"job"</span> <span class="attr">class</span>=<span class="string">" xx.xx.xx.Job"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cronTask"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetObject"</span> <span class="attr">ref</span>=<span class="string">"job"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetMethod"</span> <span class="attr">value</span>=<span class="string">"runWork"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- false表示job不会并发执行，默认为true--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"concurrent"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!—配置触发器--</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"doWork"</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.CronTriggerBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jobDetail"</span> <span class="attr">ref</span>=<span class="string">"cronTask"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">!—每天凌晨0点1分执行--</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cronExpression"</span> <span class="attr">value</span>=<span class="string">"0 01 00 * * ?"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!—最后配置调度工厂--</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.scheduling.quartz.SchedulerFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"triggers"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">"doWork"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="spring-task"><a href="#spring-task" class="headerlink" title="spring-task"></a>spring-task</h3><p>Spring从3.0开始增加了自己的任务调度器，它是通过扩展java.util.concurrent包下面的类来实现的，也称spring-schedule</p><ol><li>特点</li></ol><ul><li>默认单线程同步执行</li><li>单个任务时，当前次的调度完成后，再执行下一次任务调度</li><li>多个任务时，一个任务执行完成后才会执行下一个任务。若需要任务能够并发执行，需手动设置线程池</li></ul><ol start="2"><li>默认单线程同步执行<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:task</span>=<span class="string">"http://www.springframework.org/schema/task"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">task:annotation-driven</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myTask"</span> <span class="attr">class</span>=<span class="string">"me.changjie.task.MyTask"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&lt;task:scheduler id="scheduler" pool-size="5" /&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&lt;task:scheduled-tasks scheduler="scheduler"&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">task:scheduled-tasks</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--两个任务间隔10s执行--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">task:scheduled</span> <span class="attr">ref</span>=<span class="string">"myTask"</span> <span class="attr">method</span>=<span class="string">"method1"</span> <span class="attr">cron</span>=<span class="string">"0 33 13 * * ?"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">task:scheduled</span> <span class="attr">ref</span>=<span class="string">"myTask"</span> <span class="attr">method</span>=<span class="string">"method2"</span> <span class="attr">cron</span>=<span class="string">"10 33 13 * * ?"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">task:scheduled-tasks</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"method1 execute thread:"</span>+Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">"method1 execute time:"</span>+<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"method2 execute thread:"</span>+Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">"method2 execute time:"</span>+<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">method1 execute thread:pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">method1 execute time:<span class="number">2018</span>-<span class="number">10</span>-<span class="number">19</span> <span class="number">13</span>:<span class="number">33</span>:<span class="number">00</span></span><br><span class="line">method2 execute thread:pool-<span class="number">1</span>-thread-<span class="number">1</span></span><br><span class="line">method2 execute time:<span class="number">2018</span>-<span class="number">10</span>-<span class="number">19</span> <span class="number">13</span>:<span class="number">33</span>:<span class="number">20</span></span><br></pre></td></tr></table></figure></p><ol start="3"><li>设置线程池使其任务并行</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:task</span>=<span class="string">"http://www.springframework.org/schema/task"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">task:annotation-driven</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myTask"</span> <span class="attr">class</span>=<span class="string">"me.changjie.task.MyTask"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"scheduler"</span> <span class="attr">pool-size</span>=<span class="string">"5"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">task:scheduled-tasks</span> <span class="attr">scheduler</span>=<span class="string">"scheduler"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;task:scheduled-tasks&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">task:scheduled</span> <span class="attr">ref</span>=<span class="string">"myTask"</span> <span class="attr">method</span>=<span class="string">"method1"</span> <span class="attr">cron</span>=<span class="string">"0 36 13 * * ?"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">task:scheduled</span> <span class="attr">ref</span>=<span class="string">"myTask"</span> <span class="attr">method</span>=<span class="string">"method2"</span> <span class="attr">cron</span>=<span class="string">"10 36 13 * * ?"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">task:scheduled-tasks</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">method1 execute thread:scheduler-<span class="number">1</span></span><br><span class="line">method1 execute time:<span class="number">2018</span>-<span class="number">10</span>-<span class="number">19</span> <span class="number">13</span>:<span class="number">36</span>:<span class="number">00</span></span><br><span class="line">method2 execute thread:scheduler-<span class="number">2</span></span><br><span class="line">method2 execute time:<span class="number">2018</span>-<span class="number">10</span>-<span class="number">19</span> <span class="number">13</span>:<span class="number">36</span>:<span class="number">10</span></span><br></pre></td></tr></table></figure></p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>易用性</p><ul><li>spring-quartz配置较复杂(任务、触发器、调度工厂)，但拥有spring-task所有的功能</li><li>spring-task配置较简单，但是默认单线程同步，为了避免任务阻塞，最好配置成线程池异步执行</li></ul><p>异常处理</p><ul><li>Quartz的某次执行任务过程中抛出异常，不影响下一次任务的执行，当下一次执行时间到来时，定时器会再次执行任务</li><li>SpringTask不同，一旦某个任务在执行过程中抛出异常，则整个定时器生命周期就结束，以后永远不会再执行定时器任务，所以最好全范围catch掉</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前比较常用的定时任务解决方案一般就是Spring Quartz和Task&lt;/p&gt;
&lt;h3 id=&quot;spring-quartz&quot;&gt;&lt;a href=&quot;#spring-quartz&quot; class=&quot;headerlink&quot; title=&quot;spring-quartz&quot;&gt;&lt;/a&gt;spring-quartz&lt;/h3&gt;&lt;p&gt;spring-quartz只是spring对quartz的一个包装而已。其实现是在spring-context-support中&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;特点&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;默认多线程异步执行&lt;/li&gt;
&lt;li&gt;单个任务时，在上一个调度未完成时，下一个调度时间到时，会另起一个线程开始新的调度。业务繁忙时，一个任务会有多个调度，可能导致数据处理异常&lt;/li&gt;
&lt;li&gt;多个任务时，任务之间没有直接影响，多任务执行的快慢取决于CPU的性能
    
    </summary>
    
      <category term="spring" scheme="http://yoursite.com/categories/spring/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础-Java中对象和引用的关系</title>
    <link href="http://yoursite.com/2018/10/17/Java%E5%9F%BA%E7%A1%80-Java%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/10/17/Java基础-Java中对象和引用的理解/</id>
    <published>2018-10-17T06:00:00.000Z</published>
    <updated>2018-10-19T05:50:59.866Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal an = <span class="keyword">new</span> Animal();</span><br></pre></td></tr></table></figure><p>创建一个对象，细化这个动作为:</p><ol><li>右面的”new Animal”，在堆空间里创建一个Animal对象</li><li>左面的”Animal an” 创建了一个Animal类的一个引用变量</li><li>“=” 操作符使对象引用指向刚才创建的那个Animal对象<a id="more"></a>等同于<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal an;</span><br><span class="line">an = <span class="keyword">new</span> Animal();</span><br></pre></td></tr></table></figure></li></ol><p>有两个实体：一个是对象引用变量；一个是对象本身<br><!--more--></p><h3 id="对象和引用的区别"><a href="#对象和引用的区别" class="headerlink" title="对象和引用的区别"></a>对象和引用的区别</h3><ol><li>关联性： </li></ol><ul><li>当对象的引用变量指向对象时，两者就互相联系起来，改变引用的属性，就会改变对象的属性</li><li>如果同一个对象被多个引用变量引用的话，则这些引用变量将共同影响这个对象本身 </li><li>在java中，都是通过引用来操纵对象的</li></ul><ol start="2"><li>差异性： </li></ol><ul><li>一个对象可以被不同的引用变量来操纵，同时一个引用变量也可以指向不同的对象，但是同一时刻下只能指向一个对象</li><li>从存储空间上来看，对象和引用也是相互独立的，对象一般存储在堆中，而引用存储在堆栈中（存储速度而更快)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Animal an = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Animal();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;创建一个对象，细化这个动作为:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;右面的”new Animal”，在堆空间里创建一个Animal对象&lt;/li&gt;
&lt;li&gt;左面的”Animal an” 创建了一个Animal类的一个引用变量&lt;/li&gt;
&lt;li&gt;“=” 操作符使对象引用指向刚才创建的那个Animal对象
    
    </summary>
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java集合-Map之HashMap</title>
    <link href="http://yoursite.com/2018/10/12/Java%E9%9B%86%E5%90%88-Map%E4%B9%8BHashMap/"/>
    <id>http://yoursite.com/2018/10/12/Java集合-Map之HashMap/</id>
    <published>2018-10-12T09:00:00.000Z</published>
    <updated>2018-10-17T05:42:11.228Z</updated>
    
    <content type="html"><![CDATA[<p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间<br><a id="more"></a></p><h3 id="1-8之前底层数据结构"><a href="#1-8之前底层数据结构" class="headerlink" title="1.8之前底层数据结构"></a>1.8之前底层数据结构</h3><p>JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用。 key经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的时数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><p>所谓扰动函数指的就是 HashMap 的 hash 方法。使用扰动函数之后可以减少碰撞</p><p>1.8之前的扰动函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> var0)</span> </span>&#123;</span><br><span class="line">    var0 ^= var0 &gt;&gt;&gt; <span class="number">20</span> ^ var0 &gt;&gt;&gt; <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">return</span> var0 ^ var0 &gt;&gt;&gt; <span class="number">7</span> ^ var0 &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>1.8扰动函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次</p><p>所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可<br><img src="https://camo.githubusercontent.com/eec1c575aa5ff57906dd9c9130ec7a82e212c96a/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f332f32302f313632343064626363333033643837323f773d33343826683d34323726663d706e6726733d3130393931" alt=""></p><h3 id="1-8之后"><a href="#1-8之后" class="headerlink" title="1.8之后"></a>1.8之后</h3><p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认的初始容量是16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;   </span><br><span class="line"><span class="comment">// 最大容量，超过该容量就不再扩容了</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; </span><br><span class="line"><span class="comment">// 默认的填充因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; </span><br><span class="line"><span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;k,v&gt;[] table; </span><br><span class="line"><span class="comment">// 存放具体元素的集</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line"><span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;   </span><br><span class="line"><span class="comment">// 临界值 当实际大小超过临界值(容量*填充因子)时，会进行扩容</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">// 填充因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><h3 id="loadFactor填充因子"><a href="#loadFactor填充因子" class="headerlink" title="loadFactor填充因子"></a>loadFactor填充因子</h3><p>loadFactor填充因子是控制数组存放数据的疏密程度<br>loadFactor越趋近于1，导致临界值越大，越难扩容，数据越密，链表越长，查找效率越低<br>loadFactor越趋近于0，导致临界值越小，越易扩容，数据越散，数组越大，增删效率越低<br>默认值为0.75f是官方给出的一个比较好的临界值。 　</p><h3 id="threshold临界值"><a href="#threshold临界值" class="headerlink" title="threshold临界值"></a>threshold临界值</h3><p>当实际大小超过临界值(容量 <em> 填充因子)时，会进行扩容<br>默认临界值是16</em>0.75=12，即超过12个元素时会扩容</p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>因为HashMap为了节省创建出的对象的内存占用，一开始只默认分配16个，超过临界值就会进行扩容，扩大成2倍，容量达到最大值则不再扩容<br>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize</p><h3 id="寻址函数h-amp-length-1"><a href="#寻址函数h-amp-length-1" class="headerlink" title="寻址函数h&amp;(length - 1)"></a>寻址函数h&amp;(length - 1)</h3><p>寻址函数相当于对数组长度进行取模，而且速度比直接取模快得多，除了取模运算外还有一个非常重要的责任：均匀分布table数据和充分利用空间</p><h3 id="数组长度为什么总是2的n次方"><a href="#数组长度为什么总是2的n次方" class="headerlink" title="数组长度为什么总是2的n次方"></a>数组长度为什么总是2的n次方</h3><p>&amp;运算符：如果相对应位都是1，则结果为1，否则为0<br>在构造函数中存在：capacity &lt;&lt;= 1;这样做总是能够保证HashMap的底层数组长度为2的n次方<br>length为2的幂次方，即一定是偶数，偶数减1，即是奇数，这样保证了（length-1）在二进制中最低位是1，而&amp;运算结果的最低位是1还是0就完全取决于hash值二进制的最低位。如果length为奇数，则length-1则为偶数，则length-1二进制的最低位恒为0，则&amp;位运算的结果最低位恒为0，即恒为偶数。这样table数组就只可能在偶数下标的位置存储了数据，浪费了所有奇数下标的位置，这样也更容易产生hash冲突</p><h3 id="1-6源码分析"><a href="#1-6源码分析" class="headerlink" title="1.6源码分析"></a>1.6源码分析</h3><ol><li>构造方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.entrySet = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = <span class="number">0.75F</span>;</span><br><span class="line">    <span class="keyword">this</span>.threshold = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">this</span>.table = <span class="keyword">new</span> HashMap.Entry[<span class="number">16</span>];<span class="comment">//数组长度</span></span><br><span class="line">    <span class="keyword">this</span>.init();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定数组长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(var1, <span class="number">0.75F</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化容量和填充因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> var1, <span class="keyword">float</span> var2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.entrySet = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (var1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> + var1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (var1 &gt; <span class="number">1073741824</span>) &#123;</span><br><span class="line">            var1 = <span class="number">1073741824</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (var2 &gt; <span class="number">0.0F</span> &amp;&amp; !Float.isNaN(var2)) &#123;</span><br><span class="line">            <span class="keyword">int</span> var3;</span><br><span class="line">            <span class="comment">//保证HashMap的底层数组长度为2的n次方</span></span><br><span class="line">            <span class="keyword">for</span>(var3 = <span class="number">1</span>; var3 &lt; var1; var3 &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.loadFactor = var2;</span><br><span class="line">            <span class="keyword">this</span>.threshold = (<span class="keyword">int</span>)((<span class="keyword">float</span>)var3 * var2);</span><br><span class="line">            <span class="comment">////初始化table数组，这是HashMap真实的存储容器</span></span><br><span class="line">            <span class="keyword">this</span>.table = <span class="keyword">new</span> HashMap.Entry[var3];</span><br><span class="line">            <span class="comment">//该方法为空实现，主要是给子类去实现</span></span><br><span class="line">            <span class="keyword">this</span>.init();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + var2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/4843132-05b3a55bd2686dd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600/format/webp" alt="HashMap结构"></p><ol start="2"><li>put</li></ol><p>思路：用key的hashcode经过扰动函数和寻址函数找到数组下标，再用头插法插到所在entry的最前面<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K var1, V var2)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (var1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>.putForNullKey(var2);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">//根据key的hashcode获取扰动值</span></span><br><span class="line">         <span class="keyword">int</span> var3 = hash(var1.hashCode());</span><br><span class="line">         <span class="comment">//寻址，即对数组长度进行取模,算出所在数组下标</span></span><br><span class="line">         <span class="keyword">int</span> var4 = indexFor(var3, <span class="keyword">this</span>.table.length);</span><br><span class="line"><span class="comment">//遍历数组元素的链表</span></span><br><span class="line">         <span class="keyword">for</span>(HashMap.Entry var5 = <span class="keyword">this</span>.table[var4]; var5 != <span class="keyword">null</span>; var5 = var5.next) &#123;</span><br><span class="line">         <span class="comment">//不同变量的hash值可能会相同</span></span><br><span class="line">             <span class="keyword">if</span> (var5.hash == var3) &#123;</span><br><span class="line">                 Object var6 = var5.key;</span><br><span class="line">                 <span class="comment">//key值存在的话替换value值，返回旧值</span></span><br><span class="line">                 <span class="keyword">if</span> (var5.key == var1 || var1.equals(var6)) &#123;</span><br><span class="line">                     Object var7 = var5.value;</span><br><span class="line">                     var5.value = var2;</span><br><span class="line">                     var5.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                     <span class="keyword">return</span> var7;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         ++<span class="keyword">this</span>.modCount;</span><br><span class="line">         <span class="keyword">this</span>.addEntry(var3, var1, var2, var4);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> var1, K var2, V var3, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">     HashMap.Entry var5 = <span class="keyword">this</span>.table[var4];<span class="comment">//数组对应的entry</span></span><br><span class="line">     <span class="comment">//构建新的entry,将原entry作为新entry的next元素,即头插法,插到链表的最前面</span></span><br><span class="line">     <span class="keyword">this</span>.table[var4] = <span class="keyword">new</span> HashMap.Entry(var1, var2, var3, var5);</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>.size++ &gt;= <span class="keyword">this</span>.threshold) &#123;</span><br><span class="line">     <span class="comment">//扩容</span></span><br><span class="line">         <span class="keyword">this</span>.resize(<span class="number">2</span> * <span class="keyword">this</span>.table.length);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line">     HashMap.Entry[] var2 = <span class="keyword">this</span>.table;</span><br><span class="line">     <span class="keyword">int</span> var3 = var2.length;</span><br><span class="line">     <span class="keyword">if</span> (var3 == <span class="number">1073741824</span>) &#123;</span><br><span class="line">         <span class="keyword">this</span>.threshold = <span class="number">2147483647</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">//创建一个新的table，长度为之前的两倍</span></span><br><span class="line">         HashMap.Entry[] var4 = <span class="keyword">new</span> HashMap.Entry[var1];<span class="comment">//</span></span><br><span class="line">         <span class="keyword">this</span>.transfer(var4);</span><br><span class="line">         <span class="keyword">this</span>.table = var4;</span><br><span class="line">         <span class="comment">//重新计算临界值</span></span><br><span class="line">         <span class="keyword">this</span>.threshold = (<span class="keyword">int</span>)((<span class="keyword">float</span>)var1 * <span class="keyword">this</span>.loadFactor);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//通过遍历的方式，将老table的数据，重新寻址并存储到新table的适当位置</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(HashMap.Entry[] var1)</span> </span>&#123;</span><br><span class="line">     HashMap.Entry[] var2 = <span class="keyword">this</span>.table;</span><br><span class="line">     <span class="keyword">int</span> var3 = var1.length;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var2.length; ++var4) &#123;</span><br><span class="line">         HashMap.Entry var5 = var2[var4];</span><br><span class="line">         <span class="keyword">if</span> (var5 != <span class="keyword">null</span>) &#123;</span><br><span class="line">             var2[var4] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">             HashMap.Entry var6;</span><br><span class="line">             <span class="keyword">do</span> &#123;</span><br><span class="line">                 var6 = var5.next;</span><br><span class="line">                 <span class="comment">//重新寻址</span></span><br><span class="line">                 <span class="keyword">int</span> var7 = indexFor(var5.hash, var3);</span><br><span class="line">                 var5.next = var1[var7];</span><br><span class="line">                 var1[var7] = var5;</span><br><span class="line">                 var5 = var6;</span><br><span class="line">             &#125; <span class="keyword">while</span>(var6 != <span class="keyword">null</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>get(Object key)</li></ol><p>思路：用key的hashcode经过扰动函数和寻址函数找到数组下标，再遍历单向链表<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (var1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getForNullKey();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> var2 = hash(var1.hashCode());</span><br><span class="line">            <span class="keyword">for</span>(HashMap.Entry var3 = <span class="keyword">this</span>.table[indexFor(var2, <span class="keyword">this</span>.table.length)]; var3 != <span class="keyword">null</span>; var3 = var3.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (var3.hash == var2) &#123;</span><br><span class="line">                    Object var4 = var3.key;</span><br><span class="line">                    <span class="keyword">if</span> (var3.key == var1 || var1.equals(var4)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> var3.value;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ol start="4"><li><p>remove(Object var1)<br>思路：同样用key的hashcode经过扰动函数和寻址函数找到数组下标，再操作单向链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">       HashMap.Entry var2 = <span class="keyword">this</span>.removeEntryForKey(var1);</span><br><span class="line">       <span class="keyword">return</span> var2 == <span class="keyword">null</span> ? <span class="keyword">null</span> : var2.value;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> HashMap.<span class="function">Entry&lt;K, V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object var1)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> var2 = var1 == <span class="keyword">null</span> ? <span class="number">0</span> : hash(var1.hashCode());</span><br><span class="line">       <span class="keyword">int</span> var3 = indexFor(var2, <span class="keyword">this</span>.table.length);</span><br><span class="line">       HashMap.Entry var4 = <span class="keyword">this</span>.table[var3];</span><br><span class="line"></span><br><span class="line">       HashMap.Entry var5;</span><br><span class="line">       HashMap.Entry var6;</span><br><span class="line">       <span class="keyword">for</span>(var5 = var4; var5 != <span class="keyword">null</span>; var5 = var6) &#123;</span><br><span class="line">           var6 = var5.next;</span><br><span class="line">           <span class="keyword">if</span> (var5.hash == var2) &#123;</span><br><span class="line">               Object var7 = var5.key;</span><br><span class="line">               <span class="keyword">if</span> (var5.key == var1 || var1 != <span class="keyword">null</span> &amp;&amp; var1.equals(var7)) &#123;</span><br><span class="line">                   ++<span class="keyword">this</span>.modCount;</span><br><span class="line">                   --<span class="keyword">this</span>.size;</span><br><span class="line">                   <span class="keyword">if</span> (var4 == var5) &#123;</span><br><span class="line">                       <span class="keyword">this</span>.table[var3] = var6;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       var4.next = var6;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   var5.recordRemoval(<span class="keyword">this</span>);</span><br><span class="line">                   <span class="keyword">return</span> var5;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           var4 = var5;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> var5;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>entrySet()<br>EntrySet重写了iterator方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> java.util.Map.<span class="function">Entry&lt;K, V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.nextEntry();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> HashMap.<span class="function">Entry&lt;K, V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (HashMap.<span class="keyword">this</span>.modCount != <span class="keyword">this</span>.expectedModCount) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    HashMap.Entry var1 = <span class="keyword">this</span>.next;</span><br><span class="line">        <span class="keyword">if</span> (var1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果遍历到table单向链表的最后一个元素时</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">this</span>.next = var1.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    HashMap.Entry[] var2 = HashMap.<span class="keyword">this</span>.table;</span><br><span class="line"><span class="comment">//继续往下寻找table上有元素的下标</span></span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">this</span>.index &lt; var2.length &amp;&amp; (<span class="keyword">this</span>.next = var2[<span class="keyword">this</span>.index++]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.current = var1;</span><br><span class="line">            <span class="keyword">return</span> var1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>可知，HashMap的遍历，是依次遍历table上每一条单向链表，这不是插入的顺序，所以说：HashMap是无序的</p><h3 id="key为null的处理"><a href="#key为null的处理" class="headerlink" title="key为null的处理"></a>key为null的处理</h3><ol><li><p>key为null的put<br>其实就是放在table[0]的链表里</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V var1)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(HashMap.Entry var2 = <span class="keyword">this</span>.table[<span class="number">0</span>]; var2 != <span class="keyword">null</span>; var2 = var2.next) &#123;</span><br><span class="line">           <span class="keyword">if</span> (var2.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">               Object var3 = var2.value;</span><br><span class="line">               var2.value = var1;</span><br><span class="line">               var2.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">               <span class="keyword">return</span> var3;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ++<span class="keyword">this</span>.modCount;</span><br><span class="line">       <span class="comment">//插入到table[0]上单向链表的头部</span></span><br><span class="line">       <span class="keyword">this</span>.addEntry(<span class="number">0</span>, (Object)<span class="keyword">null</span>, var1, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>key为null的get<br>其实就是遍历table[0]的单向链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(HashMap.Entry var1 = <span class="keyword">this</span>.table[<span class="number">0</span>]; var1 != <span class="keyword">null</span>; var1 = var1.next) &#123;</span><br><span class="line">           <span class="keyword">if</span> (var1.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> var1.value;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><p>所以，在HashMap中，不允许key重复，而key为null的情况，只允许一个key为null的Entry，并且存储在table[0]的单向链表上</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>HashMap是基于哈希表实现的，用Entry[]来存储数据，而Entry中封装了key、value、hash以及Entry类型的next</li><li>HashMap存储数据是无序的</li><li>hash冲突是通过拉链法解决的</li><li>HashMap的容量永远为2的幂次方，有利于哈希表的散列</li><li>HashMap不支持存储多个相同的key，且只保存一个key为null的值，多个会覆盖</li><li>put过程，是先通过key算出hash，然后用hash算出应该存储在table中的index，然后遍历table[index]，看是否有相同的key存在，存在，则更新value；不存在则插入到table[index]单向链表的表头，时间复杂度为O(n)</li><li>get过程，通过key算出hash，然后用hash算出应该存储在table中的index，然后遍历table[index]，然后比对key，找到相同的key，则取出其value，时间复杂度为O(n)</li><li>HashMap是线程不安全的，如果有线程安全需求，推荐使用ConcurrentHashMap</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><blockquote><p><a href="https://www.jianshu.com/p/dde9b12343c1" target="_blank" rel="noopener">图解HashMap原理</a>  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间&lt;br&gt;
    
    </summary>
    
      <category term="java集合" scheme="http://yoursite.com/categories/java%E9%9B%86%E5%90%88/"/>
    
    
  </entry>
  
  <entry>
    <title>多线程-ThreadPoolExecutor用法</title>
    <link href="http://yoursite.com/2018/10/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B-ThreadPoolExecutor%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2018/10/12/多线程-ThreadPoolExecutor用法/</id>
    <published>2018-10-12T07:10:00.000Z</published>
    <updated>2018-10-12T07:24:33.690Z</updated>
    
    <content type="html"><![CDATA[<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> corePoolSize;<span class="comment">//核心线程数，默认情况下核心线程会一直存活，即使处于闲置状态也不会受存keepAliveTime限制。除非将allowCoreThreadTimeOut设置为true</span></span><br><span class="line"><span class="keyword">int</span> maximumPoolSize<span class="comment">//线程池所能容纳的最大线程数。超过这个数的线程将被阻塞。当任务队列为没有设置大小的LinkedBlockingDeque时，这个值无效</span></span><br><span class="line"><span class="keyword">long</span> keepAliveTime<span class="comment">//非核心线程的闲置超时时间，超过这个时间就会被回收</span></span><br><span class="line">TimeUnit unit<span class="comment">//指定keepAliveTime的单位</span></span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue<span class="comment">//线程池中的任务队列，常用的是：ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue</span></span><br><span class="line">ThreadFactory threadFactory<span class="comment">//线程工厂，提供创建新线程的功能</span></span><br><span class="line">RejectedExecutionHandler handler<span class="comment">//拒绝策略，线程池线程数达到最大值并且任务队列满时触发</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li>getCorePoolSize()：返回核心线程数量，即corePoolSize</li><li>getPoolSize()：返回当前线程池中线程数，刚创建线程池时线程数为0，直到有任务提交过来才创建线程</li><li>getQueue().size()：获取当前任务队列的实际容量</li></ol><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><ol><li>SynchronousQueue：直接提交的队列</li></ol><p>该任务队列没有容量，新任务总是提交给线程执行，如果活跃线程达到最大值，新任务提交会执行拒绝策略，这种队列会导致线程数过多或太容易触发拒绝策略一般不建议使用</p><ol start="2"><li>ArrayBlockingQueue：有界任务队列</li></ol><p>构造函数必须传容量表示任务队列的最大值<br>新任务提交，若线程池实际线程数小于核心线程数的话会创建线程，等于核心线程数的话会把任务放入队列中，队列满的话创建新的线程，达到最大线程数并且队列满的话执行拒绝策略</p><ol start="3"><li>LinkedBlockingQueue：无界任务队列</li></ol><p>新任务提交，若线程池实际线程数小于核心线程数的话会创建线程，等于核心线程数的话会把任务放入队列中，由于是无界（其实也是有最大值的），队列基本不会满，新任务会一直放入队列中而不会创建新的线程，使用不当会发生内存溢出<br>所以一般会设置个容量，队列满时创建新线程，达到最大线程数并且队列满的话执行拒绝策略</p><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><ol><li><p>AbortPolicy：默认拒绝策略，新任务会被拒绝并抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line"><span class="string">" rejected from "</span> +</span><br><span class="line">e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>DiscardPolicy：直接丢弃被拒绝的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>DiscardOldestPolicy：如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">    e.getQueue().poll();</span><br><span class="line">    e.execute(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>CallerRunsPolicy：交由调用者线程来执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">    r.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;属性&quot;&gt;&lt;a href=&quot;#属性&quot; class=&quot;headerlink&quot; title=&quot;属性&quot;&gt;&lt;/a&gt;属性&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; corePoolSize;&lt;span class=&quot;comment&quot;&gt;//核心线程数，默认情况下核心线程会一直存活，即使处于闲置状态也不会受存keepAliveTime限制。除非将allowCoreThreadTimeOut设置为true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; maximumPoolSize&lt;span class=&quot;comment&quot;&gt;//线程池所能容纳的最大线程数。超过这个数的线程将被阻塞。当任务队列为没有设置大小的LinkedBlockingDeque时，这个值无效&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; keepAliveTime&lt;span class=&quot;comment&quot;&gt;//非核心线程的闲置超时时间，超过这个时间就会被回收&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TimeUnit unit&lt;span class=&quot;comment&quot;&gt;//指定keepAliveTime的单位&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BlockingQueue&amp;lt;Runnable&amp;gt; workQueue&lt;span class=&quot;comment&quot;&gt;//线程池中的任务队列，常用的是：ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ThreadFactory threadFactory&lt;span class=&quot;comment&quot;&gt;//线程工厂，提供创建新线程的功能&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RejectedExecutionHandler handler&lt;span class=&quot;comment&quot;&gt;//拒绝策略，线程池线程数达到最大值并且任务队列满时触发&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="多线程" scheme="http://yoursite.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql-按小时统计数据</title>
    <link href="http://yoursite.com/2018/10/11/Mysql-%E6%8C%89%E5%B0%8F%E6%97%B6%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2018/10/11/Mysql-按小时统计数据/</id>
    <published>2018-10-11T09:00:00.000Z</published>
    <updated>2018-10-11T08:56:37.465Z</updated>
    
    <content type="html"><![CDATA[<p>Mysql统计一天中每小时数据量sql如下<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> created, <span class="keyword">count</span>(created)</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">       <span class="keyword">select</span> <span class="keyword">DATE_FORMAT</span>( created ,<span class="string">'%Y-%m-%d %H'</span>) created </span><br><span class="line">       <span class="keyword">from</span> shop_check_result </span><br><span class="line">       <span class="keyword">where</span> created &gt; <span class="string">'2018-10-08 00:00:00'</span> <span class="keyword">and</span> created &lt; <span class="string">'2018-10-09 00:00:00'</span> </span><br><span class="line">     ) a</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> created;</span><br></pre></td></tr></table></figure></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mysql统计一天中每小时数据量sql如下&lt;br&gt;&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; created, &lt;span class=&quot;keyword&quot;&gt;count&lt;/span&gt;(created)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;DATE_FORMAT&lt;/span&gt;( created ,&lt;span class=&quot;string&quot;&gt;&#39;%Y-%m-%d %H&#39;&lt;/span&gt;) created &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; shop_check_result &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;where&lt;/span&gt; created &amp;gt; &lt;span class=&quot;string&quot;&gt;&#39;2018-10-08 00:00:00&#39;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;and&lt;/span&gt; created &amp;lt; &lt;span class=&quot;string&quot;&gt;&#39;2018-10-09 00:00:00&#39;&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     ) a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;by&lt;/span&gt; created;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>Java集合-List之LinkedList</title>
    <link href="http://yoursite.com/2018/10/10/Java%E9%9B%86%E5%90%88-List%E4%B9%8BLinkedList/"/>
    <id>http://yoursite.com/2018/10/10/Java集合-List之LinkedList/</id>
    <published>2018-10-10T11:10:00.000Z</published>
    <updated>2018-10-10T12:17:39.793Z</updated>
    
    <content type="html"><![CDATA[<p>LinkedList底层的链表结构使它支持高效的插入和删除操作，另外它实现了Deque接口，使得LinkedList类也具有队列的特性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;<span class="comment">//节点值</span></span><br><span class="line">    Node&lt;E&gt; next;<span class="comment">//前驱节点</span></span><br><span class="line">    Node&lt;E&gt; prev;<span class="comment">//后继节点</span></span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ol><li><p>属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;<span class="comment">//链表的元素个数</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;<span class="comment">//头节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;<span class="comment">//尾节点</span></span><br></pre></td></tr></table></figure></li><li><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();<span class="comment">//调用无参构造方法</span></span><br><span class="line">    addAll(c);<span class="comment">//添加元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>addFirst：将元素插入到最前面</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);<span class="comment">//创建新元素,前驱节点为null,后继节点为之前的头结点</span></span><br><span class="line">    first = newNode;<span class="comment">//将新元素设为头结点</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    f.prev = newNode;<span class="comment">//将新元素作为原来头结点的前驱节点</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>addLast/add：将元素插入到最后面</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);<span class="comment">//创建新元素,后继节点为null,后继节点为之前的尾结点</span></span><br><span class="line">    last = newNode;<span class="comment">//将新元素设为尾结点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    l.next = newNode;<span class="comment">//将新元素作为原来尾结点的后继节点</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>add(int index, E element)：在指定位置插入元素</li></ol><p>新节点的前驱为指定位置元素的前驱，新节点的后继指定位置元素<br>指定位置元素的前驱节点的后继设为新元素，指定位置的前驱设为新元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">    linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;<span class="comment">//找出指定位置的前驱节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);<span class="comment">//创建新元素，后继元素即为指定位置元素，前驱为指定位置的原前驱</span></span><br><span class="line">    succ.prev = newNode;<span class="comment">//将新元素作为指定位置元素的新前驱</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    pred.next = newNode;<span class="comment">//将新元素作为指定元素原前驱节点的新后继</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="6"><li>removeFirst/remove：删除第一个元素</li></ol><p>将头结点的后继节点设为新的头结点，再把新的头结点的前驱设置null</p><ol start="7"><li>removeLast：删除最后一个元素</li></ol><p>将最后元素的前驱作为新的尾节点，再把新的尾节点的后继设为null</p><ol start="8"><li>remove(int index)：删除指定位置的元素</li></ol><p>先根据索引找到这个节点(从头结点开始找)，再修改这个节点的前驱的后继和后继的前驱即可</p><ol start="9"><li>remove(Object o)：删除指定内容的元素</li></ol><p>先根据内容找到这个节点(从头结点开始找)，再修改这个节点的前驱的后继和后继的前驱即可</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>无论是根据指定索引位置进行查找还是根据指定元素内容进行查找，都需要从头结点进行遍历<br>插入和删除的话只需要操作前驱和后继元素即可</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LinkedList底层的链表结构使它支持高效的插入和删除操作，另外它实现了Deque接口，使得LinkedList类也具有队列的特性&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Node&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;E&lt;/span&gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    E item;&lt;span class=&quot;comment&quot;&gt;//节点值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Node&amp;lt;E&amp;gt; next;&lt;span class=&quot;comment&quot;&gt;//前驱节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Node&amp;lt;E&amp;gt; prev;&lt;span class=&quot;comment&quot;&gt;//后继节点&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.item = element;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.next = next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.prev = prev;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java集合" scheme="http://yoursite.com/categories/java%E9%9B%86%E5%90%88/"/>
    
    
  </entry>
  
  <entry>
    <title>Java集合-List之ArrayList</title>
    <link href="http://yoursite.com/2018/10/10/Java%E9%9B%86%E5%90%88-List%E4%B9%8BArrayList/"/>
    <id>http://yoursite.com/2018/10/10/Java集合-List之ArrayList/</id>
    <published>2018-10-10T07:10:00.000Z</published>
    <updated>2018-10-10T09:44:09.574Z</updated>
    
    <content type="html"><![CDATA[<p>ArrayList 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure></p><p>transient作用是为了序列化时只序列化数组内的实际元素<br><a id="more"></a></p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ol><li><p>属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;<span class="comment">//保存ArrayList数据的数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;<span class="comment">//缺省容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//空对象数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<span class="comment">//缺省空对象数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//实际元素大小，默认为0</span></span><br></pre></td></tr></table></figure></li><li><p>构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<span class="comment">//并不会真正产生实例化的数组，而是引用一个静态的空数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];<span class="comment">//创建指定大小的数组</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<span class="comment">//并不会真正产生实例化的数组，而是引用一个静态的空数组</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();<span class="comment">//转成数组</span></span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;<span class="comment">//数组不为空</span></span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);<span class="comment">//数组拷贝生成新数组对象</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>add方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// 扩容判断</span></span><br><span class="line">    elementData[size++] = e;<span class="comment">//添加到末尾</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);<span class="comment">//使用无参构造实例化时，引用的是空数组，添加第一个元素这里扩展成默认容量10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">    grow(minCapacity);<span class="comment">//扩容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;<span class="comment">//旧容量</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//新容量扩成原来的1.5倍 右移n就是除以2的n次方</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = minCapacity;<span class="comment">//扩到1.5倍还不够的话，一步到位</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">    newCapacity = hugeCapacity(minCapacity);<span class="comment">//最大容量判断</span></span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);<span class="comment">//拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>addAll方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">//先扩容</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);<span class="comment">//将目标数组元素全部拷贝到原元素组后面</span></span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>remove方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据索引位置去删除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);<span class="comment">//检查索引是否合法</span></span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">    numMoved);<span class="comment">//从指定位置后面往前复制</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">//赋值为空，有利于进行GC</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;<span class="comment">//返回旧值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据元素内容去删除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;<span class="comment">//可以看出Arraylist允许元素为null</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">    <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">    fastRemove(index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">        <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">        fastRemove(index);<span class="comment">//先找到元素位置，在根据索引位置去删除</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">    System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">    numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>get方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="减少扩容次数"><a href="#减少扩容次数" class="headerlink" title="减少扩容次数"></a>减少扩容次数</h3><p>在创建ArrayList之前知道要插入的对象的数目的话，直接使用有参构造即可<br>当创建ArrayList之后知道要插入的对象的数目的话，最好提前扩容，不然每添加到一定元素就需要扩容拷贝，可调用ensureCapacity(int minCapacity)方法扩容一次即可，来提高效率<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//扩容到可容纳minCapacity</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">    <span class="comment">// any size if not default element table</span></span><br><span class="line">    ? <span class="number">0</span></span><br><span class="line">    <span class="comment">// larger than default for default empty table. It's already</span></span><br><span class="line">    <span class="comment">// supposed to be at default size.</span></span><br><span class="line">    : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="ArrayList与数组的区别"><a href="#ArrayList与数组的区别" class="headerlink" title="ArrayList与数组的区别"></a>ArrayList与数组的区别</h3><p>既然ArrayList内部由数组实现,那二者有什么区别呢？</p><ol><li>数组可存放基本类型和对象类型，而ArrayList只可存放对象类型</li><li>ArrayList提供了更丰富的api操作</li><li>Arraylist大小是动态变化的，Array定长</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ArrayList 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; Object[] elementData;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;transient作用是为了序列化时只序列化数组内的实际元素&lt;br&gt;
    
    </summary>
    
      <category term="java集合" scheme="http://yoursite.com/categories/java%E9%9B%86%E5%90%88/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础-static关键字</title>
    <link href="http://yoursite.com/2018/10/10/static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2018/10/10/static关键字/</id>
    <published>2018-10-10T03:10:00.000Z</published>
    <updated>2018-10-10T03:30:42.785Z</updated>
    
    <content type="html"><![CDATA[<p>static关键字主要用于下面几种场景</p><h3 id="修饰成员变量和成员方法"><a href="#修饰成员变量和成员方法" class="headerlink" title="修饰成员变量和成员方法"></a>修饰成员变量和成员方法</h3><p>被 static 修饰的成员变量属于类，不属于单个这个类的某个对象，被类中所有对象共享，建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量存放在 Java 内存区域的方法区。<br>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。<br>HotSpot 虚拟机中方法区也常被称为 “永久代”，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但这样更容易遇到内存溢出问题<br><a id="more"></a></p><h3 id="修饰静态块"><a href="#修饰静态块" class="headerlink" title="修饰静态块"></a>修饰静态块</h3><p>静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。 该类不管创建多少对象，静态代码块只执行一次<br>由于静态代码块只执行一次，其实这里也可以去实现单例模式，本质上和饿汉模式一样，实例初始化过早，一般不建议使用</p><h3 id="修饰内部类-只能修饰内部类"><a href="#修饰内部类-只能修饰内部类" class="headerlink" title="修饰内部类(只能修饰内部类)"></a>修饰内部类(只能修饰内部类)</h3><p>静态内部类与非静态内部类之间存在一个最大的区别：非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外部类，但是静态内部类却没有<br>所以静态内部类的创建不需要依赖外部类的创建，也不能使用外部类的非static成员变量和方法(非静态内部类可直接使用外部类的所有(包括私有)属性和方法)<br>静态内部类比较常见的是实现线程安全的单例模式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//声明为 private 避免调用默认构造方法创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//声明为 private 表明静态内部该类只能在外部类中被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当 外部类加载时，静态内部类并没有被加载进内存。只有当调用 getUniqueInstance()方法从而触发 SingletonHolder.INSTANCE 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。<br>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持</p><h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h3><blockquote><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/Java%E7%9B%B8%E5%85%B3/static.md" target="_blank" rel="noopener">static 关键字</a>  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;static关键字主要用于下面几种场景&lt;/p&gt;
&lt;h3 id=&quot;修饰成员变量和成员方法&quot;&gt;&lt;a href=&quot;#修饰成员变量和成员方法&quot; class=&quot;headerlink&quot; title=&quot;修饰成员变量和成员方法&quot;&gt;&lt;/a&gt;修饰成员变量和成员方法&lt;/h3&gt;&lt;p&gt;被 static 修饰的成员变量属于类，不属于单个这个类的某个对象，被类中所有对象共享，建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量存放在 Java 内存区域的方法区。&lt;br&gt;方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。&lt;br&gt;HotSpot 虚拟机中方法区也常被称为 “永久代”，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但这样更容易遇到内存溢出问题&lt;br&gt;
    
    </summary>
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础-内部类中调用外部局部变量为何用final修饰</title>
    <link href="http://yoursite.com/2018/10/10/%E5%86%85%E9%83%A8%E7%B1%BB%E8%B0%83%E7%94%A8%E5%B1%80%E9%83%A8%E5%8F%82%E6%95%B0%E4%B8%BA%E4%BD%95%E7%94%A8final%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2018/10/10/内部类调用局部参数为何用final关键字/</id>
    <published>2018-10-10T02:45:00.000Z</published>
    <updated>2018-10-10T02:39:31.487Z</updated>
    
    <content type="html"><![CDATA[<p>在平时写代码中经常会在方法中起一个线程，但是在局部内部类中使用外部局部变量的话编译器会提示将外部局部变量定义为final类型，这是为什么呢<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> String a, String b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><ol><li>在局部内部类可以访问方法的形参或局部变量<br>从程序设计语言的理论上:局部内部类(即:定义在方法中的内部类),由于本身就是在方法内部,因而可以访问方法中的局部变量(形式参数或局部变量)</li><li>怎么解决局部变量的生命周期与局部内部类的对象的生命周期的不一致<br>当在内部类试图访问外部方法中的局部变量时，外部方法的局部变量很可能已经不存在了，那么就得延续其生命，拷贝到内部类中，而拷贝会带来不一致性，从而需要使用final声明保证一致性。</li><li>java8的优化<br>1.8之前在局部内部类使用外部局部变量的话，需要将外部局部变量显式定义为final类型，不然编译期就会提示出错<br>1.8就不需要显式定义为final类型了，但是如果试图改变外部的局部变量引用的话，就会提示需要定义为final类型，其实是语法糖带来的效果</li><li>总结<br>复制保证生命周期延续，final保证引用一致</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><blockquote><p><a href="http://feiyeguohai.iteye.com/blog/1500108" target="_blank" rel="noopener">为什么匿名内部类参数必须为final类型</a><br><a href="https://www.jianshu.com/p/d70f9832d66b" target="_blank" rel="noopener">为在jdk1.8以前匿名内部类使用外部类变量必须是final的原因</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在平时写代码中经常会在方法中起一个线程，但是在局部内部类中使用外部局部变量的话编译器会提示将外部局部变量定义为final类型，这是为什么呢&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; String a, String b)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Runnable() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                Thread.sleep(&lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(Thread.currentThread().getName() + &lt;span class=&quot;string&quot;&gt;&quot;:&quot;&lt;/span&gt;+a);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;).start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础-servlet与jsp</title>
    <link href="http://yoursite.com/2018/10/09/servlet%E4%B8%8Ejsp/"/>
    <id>http://yoursite.com/2018/10/09/servlet与jsp/</id>
    <published>2018-10-09T09:00:00.000Z</published>
    <updated>2018-10-09T09:55:17.561Z</updated>
    
    <content type="html"><![CDATA[<h3 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h3><p>在Java Web程序中，Servlet主要负责接收用户请求HttpServletRequest,在doGet(),doPost()中做相应的处理，并将回应HttpServletResponse反馈给用户<br>Servlet可以设置初始化参数，供Servlet内部使用<br>一个Servlet类只会有一个实例，在它初始化时调用init()方法，销毁时调用destroy()方法<br>Servlet需要在web.xml中配置，一个Servlet可以设置多个URL访问<br>Servlet不是线程安全，因此要谨慎使用类变量<br><a id="more"></a></p><h3 id="servlet生命周期"><a href="#servlet生命周期" class="headerlink" title="servlet生命周期"></a>servlet生命周期</h3><p>Web容器加载Servlet并将其实例化后，Servlet生命周期开始<br>容器运行其init()方法进行Servlet的初始化<br>请求到达时调用Servlet的service()方法，service()方法会根据需要调用与请求对应的doGet或doPost等方法<br>当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的destroy()方法<br>init方法和destory方法只会执行一次，service方法客户端每次请求Servlet都会执行</p><h3 id="转发和重定向"><a href="#转发和重定向" class="headerlink" title="转发和重定向"></a>转发和重定向</h3><p>转发是服务端行为，重定向是客户端行为<br>转发（Forword）：通过RequestDispatcher对象的forward方法实现的。RequestDispatcher可以通过HttpServletRequest 的getRequestDispatcher()方法获得。例如下面的代码就是跳转到login_success.jsp页面<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">"login_success.jsp"</span>).forward(request, response);</span><br></pre></td></tr></table></figure></p><p>重定向（Redirect)：是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过HttpServletRequestResponse的setStatus(int status)方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源</p><h3 id="jsp与servlet"><a href="#jsp与servlet" class="headerlink" title="jsp与servlet"></a>jsp与servlet</h3><p>Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。<br>JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。<br>Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。可以理解为Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码。<br>JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）</p><h3 id="jsp工作原理"><a href="#jsp工作原理" class="headerlink" title="jsp工作原理"></a>jsp工作原理</h3><p>JSP是一种Servlet，但是与HttpServlet的工作方式不太一样。HttpServlet是先由源代码编译为class文件后部署到服务器下，为先编译后部署。<br>而JSP则是先部署后编译。JSP会在客户端第一次请求JSP文件时被编译为HttpJspPage类（接口Servlet的一个子类）。该类会被服务器临时存放在服务器工作目录里面。第一次部署到服务器上后访问这个Jsp文件，这个目录下会生成class文件。这个class文件便是JSP对应的Servlet。编译完毕后再运行class文件来响应客户端请求。以后客户端访问login.jsp的时候，Tomcat将不再重新编译JSP文件，而是直接调用class文件来响应客户端请求。<br>JSP是在请求的时候被编译 ，因此第一次请求JSP时会感觉比较慢，之后就会感觉快很多。如果把服务器保存的class文件删除，服务器也会重新编译JSP</p><h3 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h3><ol><li>由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session。典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。</li><li>思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。</li><li>Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。</li><li>所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式</li></ol><h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h3><blockquote><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/Java%E7%9B%B8%E5%85%B3/J2EE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md" target="_blank" rel="noopener">J2EE基础知识</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;servlet&quot;&gt;&lt;a href=&quot;#servlet&quot; class=&quot;headerlink&quot; title=&quot;servlet&quot;&gt;&lt;/a&gt;servlet&lt;/h3&gt;&lt;p&gt;在Java Web程序中，Servlet主要负责接收用户请求HttpServletRequest,在doGet(),doPost()中做相应的处理，并将回应HttpServletResponse反馈给用户&lt;br&gt;Servlet可以设置初始化参数，供Servlet内部使用&lt;br&gt;一个Servlet类只会有一个实例，在它初始化时调用init()方法，销毁时调用destroy()方法&lt;br&gt;Servlet需要在web.xml中配置，一个Servlet可以设置多个URL访问&lt;br&gt;Servlet不是线程安全，因此要谨慎使用类变量&lt;br&gt;
    
    </summary>
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础-java只有值传递</title>
    <link href="http://yoursite.com/2018/10/09/java%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92/"/>
    <id>http://yoursite.com/2018/10/09/java只有值传递/</id>
    <published>2018-10-09T07:40:00.000Z</published>
    <updated>2018-10-09T08:02:48.559Z</updated>
    
    <content type="html"><![CDATA[<p>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容<br><a id="more"></a></p><h3 id="example1"><a href="#example1" class="headerlink" title="example1"></a>example1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    swap(num1, num2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"num1 = "</span> + num1);</span><br><span class="line">    System.out.println(<span class="string">"num2 = "</span> + num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"a = "</span> + a);</span><br><span class="line">    System.out.println(<span class="string">"b = "</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">20</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">num1 = <span class="number">10</span></span><br><span class="line">num2 = <span class="number">20</span></span><br></pre></td></tr></table></figure><p>解析<br><img src="https://camo.githubusercontent.com/ab46506b1a5ce09a516051c35f981e55255337f9/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d32372f32323139313334382e6a7067" alt="解析"><br>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身</p><p>一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样</p><h3 id="example2"><a href="#example2" class="headerlink" title="example2"></a>example2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    change(arr);</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>解析<br><img src="https://camo.githubusercontent.com/b7bad9506150c29bb8d7debd3905bd7a71cd6611/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d32372f333832353230342e6a7067" alt="解析"><br>array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p><h3 id="example3"><a href="#example3" class="headerlink" title="example3"></a>example3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Student s1 = <span class="keyword">new</span> Student(<span class="string">"小张"</span>);</span><br><span class="line">    Student s2 = <span class="keyword">new</span> Student(<span class="string">"小李"</span>);</span><br><span class="line">    swap(s1, s2);</span><br><span class="line">    System.out.println(<span class="string">"s1:"</span> + s1.getName());</span><br><span class="line">    System.out.println(<span class="string">"s2:"</span> + s2.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Student x, Student y)</span> </span>&#123;</span><br><span class="line">    Student temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">    System.out.println(<span class="string">"x:"</span> + x.getName());</span><br><span class="line">    System.out.println(<span class="string">"y:"</span> + y.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x:小李</span><br><span class="line">y:小张</span><br><span class="line">s1:小张</span><br><span class="line">s2:小李</span><br></pre></td></tr></table></figure><p>解析<br><img src="https://camo.githubusercontent.com/9d6dd0313695d309280675cd3251b47432a28814/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d32372f38383732393831382e6a7067" alt="交换前"><br>交换前s1和其副本x指向同一个元素，s2和y指向的是同一个元素<br><img src="https://camo.githubusercontent.com/6bea9b0ed65609d699207ab787f631f7ba0a9246/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d32372f33343338343431342e6a7067" alt="交换后"><br>交换后s1指针没变，其副本x指针变了，s2指针没变，其副本y指针变了<br>其实交换的其两个副本的指针，原对象指针不受影响</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><blockquote><p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87/%E6%9C%80%E6%9C%80%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/%E7%AC%AC%E4%B8%80%E5%91%A8%EF%BC%882018-8-7%EF%BC%89.md" target="_blank" rel="noopener">为什么 Java 中只有值传递</a>  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容&lt;br&gt;
    
    </summary>
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础-equals与hashcode</title>
    <link href="http://yoursite.com/2018/10/09/equals%E4%B8%8Ehashcode/"/>
    <id>http://yoursite.com/2018/10/09/equals与hashcode/</id>
    <published>2018-10-09T07:00:00.000Z</published>
    <updated>2018-10-09T07:27:27.209Z</updated>
    
    <content type="html"><![CDATA[<h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><p>euqals()作为Object的方法，用于判断两个对象是否相等<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很明显是对两个对象的地址值进行的比较（即比较引用是否相同）。像String 、Math、Integer、Double等这些封装类已经将其重写了，比较的是内容<br><a id="more"></a></p><h3 id="hashcode方法"><a href="#hashcode方法" class="headerlink" title="hashcode方法"></a>hashcode方法</h3><p>hashCode()也是Object的方法，用于给对象返回一个hash code值。这个方法被用于hash tables，例如HashMap<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>是一个本地方法，它的实现是根据本地机器相关,像String 、Math、Integer、Double等这些封装类已经将其重写了</p><h3 id="hashcode作用"><a href="#hashcode作用" class="headerlink" title="hashcode作用"></a>hashcode作用</h3><p>对于java中的set集合元素是不可重复的，元素是否重复通过equals方法判断。<br>但是，如果每增加一个元素就检查一次，那么当元素很多时，比较的次数就非常多了。这显然会大大降低效率。<br>于是，Java采用了哈希表的原理。哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。<br>当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。<br>简而言之，在集合查找时，hashcode能大大降低对象比较次数，提高查找效率</p><h3 id="规定"><a href="#规定" class="headerlink" title="规定"></a>规定</h3><p>Java对象的eqauls方法和hashCode方法是这样规定的：<br>1、相等（相同）的对象必须具有相等的哈希码（或者散列码）。<br>由于HashMap不允许存放重复元素，所以相同元素的hashcode必须不同<br>所以重写了equals的话必须重写hashcode<br>2、如果两个对象的hashCode相同，它们并不一定相同。<br>不同对象的hashcode可能会相同，即会产生哈希冲突</p><h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>假如两个Java对象A和B，A和B不相等（eqauls结果为false），但A和B的哈希码相等，将A和B都存入HashMap时会发生哈希冲突，也就是A和B存放在HashMap内部数组的位置索引相同这时HashMap会在该位置建立一个链表，将A和B串起来放在该位置，显然，该情况不违反HashMap的使用原则，是允许的。当然，哈希冲突越少越好，尽量采用好的哈希算法以避免哈希冲突</p><h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h3><blockquote><p><a href="https://www.cnblogs.com/Qian123/p/5703507.html" target="_blank" rel="noopener">Java提高篇——equals()与hashCode()方法详解</a>  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;equals方法&quot;&gt;&lt;a href=&quot;#equals方法&quot; class=&quot;headerlink&quot; title=&quot;equals方法&quot;&gt;&lt;/a&gt;equals方法&lt;/h3&gt;&lt;p&gt;euqals()作为Object的方法，用于判断两个对象是否相等&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object obj)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; == obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;很明显是对两个对象的地址值进行的比较（即比较引用是否相同）。像String 、Math、Integer、Double等这些封装类已经将其重写了，比较的是内容&lt;br&gt;
    
    </summary>
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>Java基础-Transient关键字的使用</title>
    <link href="http://yoursite.com/2018/09/30/transient%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/09/30/transient的作用与使用/</id>
    <published>2018-09-30T04:12:57.000Z</published>
    <updated>2018-10-09T07:25:58.773Z</updated>
    
    <content type="html"><![CDATA[<h3 id="transient的使用"><a href="#transient的使用" class="headerlink" title="transient的使用"></a>transient的使用</h3><p>对象实现了序列化接口时，这个类所有属性和方法都可以序列化和被反序列化，当我们不想序列化某些属性时，使用transient修饰这些属性即可，比如对于一些敏感信息(密码，银行卡号等)不希望在网络中传输<br><a id="more"></a></p><h4 id="传统序列化"><a href="#传统序列化" class="headerlink" title="传统序列化"></a>传统序列化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransientTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> username;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.username = username;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> password;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.password = password;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">"chang"</span>);</span><br><span class="line">        user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"read before Serializable: "</span>);</span><br><span class="line">        System.out.println(<span class="string">"username: "</span> + user.getUsername());</span><br><span class="line">        System.out.println(<span class="string">"password: "</span> + user.getPassword());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                    <span class="keyword">new</span> FileOutputStream(<span class="string">"/Users/admin/Desktop/user.txt"</span>));</span><br><span class="line">            os.writeObject(user); <span class="comment">// 将User对象写进文件</span></span><br><span class="line">            os.flush();</span><br><span class="line">            os.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ObjectInputStream is = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(</span><br><span class="line">                    <span class="string">"/Users/admin/Desktop/user.txt"</span>));</span><br><span class="line">            user = (User) is.readObject(); <span class="comment">// 从流中读取User的数据</span></span><br><span class="line">            is.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"\nread after Serializable: "</span>);</span><br><span class="line">            System.out.println(<span class="string">"username: "</span> + user.getUsername());</span><br><span class="line">            System.out.println(<span class="string">"password: "</span> + user.getPassword());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read before Serializable: </span><br><span class="line">username: chang</span><br><span class="line">password: <span class="number">123456</span></span><br><span class="line"></span><br><span class="line">read after Serializable: </span><br><span class="line">username: chang</span><br><span class="line">password: <span class="number">123456</span></span><br></pre></td></tr></table></figure></p><h4 id="使用transient修饰不想被序列化的字段"><a href="#使用transient修饰不想被序列化的字段" class="headerlink" title="使用transient修饰不想被序列化的字段"></a>使用transient修饰不想被序列化的字段</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> String password;</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read before Serializable: </span><br><span class="line">username: chang</span><br><span class="line">password: <span class="number">123456</span></span><br><span class="line"></span><br><span class="line">read after Serializable: </span><br><span class="line">username: chang</span><br><span class="line">password: <span class="keyword">null</span></span><br></pre></td></tr></table></figure></p><p>密码字段为null，说明反序列化时根本没有从文件中获取到信息</p><h3 id="静态变量不管是否被transient修饰，均不能被序列化"><a href="#静态变量不管是否被transient修饰，均不能被序列化" class="headerlink" title="静态变量不管是否被transient修饰，均不能被序列化"></a>静态变量不管是否被transient修饰，均不能被序列化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransientTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7195941599855555739L</span>;</span><br><span class="line">        <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> username;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.username = username;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> password;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.password = password;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">"chang"</span>);</span><br><span class="line">        user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"read before Serializable: "</span>);</span><br><span class="line">        System.out.println(<span class="string">"username: "</span> + user.getUsername());</span><br><span class="line">        System.out.println(<span class="string">"password: "</span> + user.getPassword());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                    <span class="keyword">new</span> FileOutputStream(<span class="string">"/Users/admin/Desktop/user.txt"</span>));</span><br><span class="line">            os.writeObject(user); <span class="comment">// 将User对象写进文件</span></span><br><span class="line">            os.flush();</span><br><span class="line">            os.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            User.password = <span class="string">"1111"</span>;<span class="comment">//在反序列化之前修改了静态变量的值</span></span><br><span class="line">            ObjectInputStream is = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(</span><br><span class="line">                    <span class="string">"/Users/admin/Desktop/user.txt"</span>));</span><br><span class="line">            user = (User) is.readObject(); <span class="comment">// 从流中读取User的数据</span></span><br><span class="line">            is.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"\nread after Serializable: "</span>);</span><br><span class="line">            System.out.println(<span class="string">"username: "</span> + user.getUsername());</span><br><span class="line">            System.out.println(<span class="string">"password: "</span> + user.getPassword());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">read before Serializable: </span><br><span class="line">username: chang</span><br><span class="line">password: <span class="number">123456</span></span><br><span class="line"></span><br><span class="line">read after Serializable: </span><br><span class="line">username: chang</span><br><span class="line">password: <span class="number">1111</span></span><br></pre></td></tr></table></figure></p><p>可知反序列化后类中静态变量的值为当前JVM中对应static变量的值，而不是序列化时的值</p><h3 id="ArrayList的实现"><a href="#ArrayList的实现" class="headerlink" title="ArrayList的实现"></a>ArrayList的实现</h3><p>ArrayList实现了List和Serializable接口，内部由elementData数组实现，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (var1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span> + var1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[var1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可知数组的初始化容量是10，每插入一个元素时都要进行最大容量判断<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E var1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ensureCapacity(<span class="keyword">this</span>.size + <span class="number">1</span>);<span class="comment">//扩容校验</span></span><br><span class="line">    <span class="keyword">this</span>.elementData[<span class="keyword">this</span>.size++] = var1;<span class="comment">//将插入的值放到尾部</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line">    ++<span class="keyword">this</span>.modCount;</span><br><span class="line">    <span class="keyword">int</span> var2 = <span class="keyword">this</span>.elementData.length;</span><br><span class="line">    <span class="keyword">if</span> (var1 &gt; var2) &#123;<span class="comment">//超过容量需要进行Arrays.copyOf扩容</span></span><br><span class="line">        Object[] var3 = <span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">int</span> var4 = var2 * <span class="number">3</span> / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (var4 &lt; var1) &#123;</span><br><span class="line">            var4 = var1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.elementData = Arrays.copyOf(<span class="keyword">this</span>.elementData, var4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>指定位置插入元素的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> var1, E var2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (var1 &lt;= <span class="keyword">this</span>.size &amp;&amp; var1 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.ensureCapacity(<span class="keyword">this</span>.size + <span class="number">1</span>);<span class="comment">//扩容校验</span></span><br><span class="line">        System.arraycopy(<span class="keyword">this</span>.elementData, var1, <span class="keyword">this</span>.elementData, var1 + <span class="number">1</span>, <span class="keyword">this</span>.size - var1);<span class="comment">//将指定位置后面的元素后移</span></span><br><span class="line">        <span class="keyword">this</span>.elementData[var1] = var2;<span class="comment">//添加到指定位置</span></span><br><span class="line">        ++<span class="keyword">this</span>.size;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span> + var1 + <span class="string">", Size: "</span> + <span class="keyword">this</span>.size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由此可见 ArrayList的主要消耗是数组扩容以及在指定位置添加数据，在日常使用时最好是指定大小，尽量减少扩容。更要减少在指定位置插入数据的操作</p><h3 id="ArrayList与transient"><a href="#ArrayList与transient" class="headerlink" title="ArrayList与transient"></a>ArrayList与transient</h3><p>通过源码得知ArrayList实现了序列化接口并且elementData是被transient修饰的，那不是序列化后的ArrayList丢失了原先的元素？<br>ArrayList内部还有两个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream var1)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var2 = <span class="keyword">this</span>.modCount;</span><br><span class="line">    var1.defaultWriteObject();</span><br><span class="line">    var1.writeInt(<span class="keyword">this</span>.elementData.length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; <span class="keyword">this</span>.size; ++var3) &#123;</span><br><span class="line">        var1.writeObject(<span class="keyword">this</span>.elementData[var3]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.modCount != var2) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    var1.defaultReadObject();</span><br><span class="line">    <span class="keyword">int</span> var2 = var1.readInt();</span><br><span class="line">    Object[] var3 = <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[var2];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; <span class="keyword">this</span>.size; ++var4) &#123;</span><br><span class="line">        var3[var4] = var1.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为什么不直接用elementData来序列化，而采用上述的方式来实现序列化呢？原因在于elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间</p><h3 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h3><blockquote><p><a href="http://www.cnblogs.com/lanxuezaipiao/p/3369962.html" target="_blank" rel="noopener">Java transient关键字使用小记</a><br><a href="https://blog.csdn.net/zero__007/article/details/52166306" target="_blank" rel="noopener">ArrayList中elementData为什么被transient修饰?</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;transient的使用&quot;&gt;&lt;a href=&quot;#transient的使用&quot; class=&quot;headerlink&quot; title=&quot;transient的使用&quot;&gt;&lt;/a&gt;transient的使用&lt;/h3&gt;&lt;p&gt;对象实现了序列化接口时，这个类所有属性和方法都可以序列化和被反序列化，当我们不想序列化某些属性时，使用transient修饰这些属性即可，比如对于一些敏感信息(密码，银行卡号等)不希望在网络中传输&lt;br&gt;
    
    </summary>
    
      <category term="java基础" scheme="http://yoursite.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
</feed>
