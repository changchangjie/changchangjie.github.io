{"pages":[{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"Dubbo-dubbo invoke的使用","text":"dubbo2.0.5以后版本提供了在线调用的方式，极大的方便了调试阶段 连接提供方12345678910111213141516171819202122[nobody@aliyun-APP-121-4 ~]$ telnet 47.92.227.5 30016Trying 47.92.227.5...Connected to 47.92.227.5.Escape character is '^]'.lscom.raycloud.template.api.IHaibaoServicedubbo&gt;ls com.raycloud.template.api.IHaibaoServicedeleteMyHaibaoqueryWatermarktransformOldWaimaiHaibaoqueryMyPosterByConditionquerySystemPosterqueryMyCollectionHaibaoqueryHaibaoCategoryqueryHaibaoByIdqueryMyHaibaoqueryMyCollectionscollectHaibaouseHaibaotransformOldHaibaoqueryHaibaodubbo&gt; invoke调用请求参数是对象1void submitHotTitleTask(HotTitleRequest request) throws Exception; 1234567891011121314151617181920212223242526272829303132public class HotTitleRequest implements Serializable { private String taobaoNick; private String keyword; public String getTaobaoNick() { return taobaoNick; } public void setTaobaoNick(String taobaoNick) { this.taobaoNick = taobaoNick; } public String getKeyword() { return keyword; } public void setKeyword(String keyword) { this.keyword = keyword; }}``` ```shellinvoke com.raycloud.qnrank.service.IRankItemService.submitHotTitleTask( { \"taobaoNick\":\"changjie\", \"keyword\":\"踏板\", \"class\":\"com.raycloud.qnrank.vo.request.HotTitleRequest\" }) 请求参数是复杂对象1234567891011121314151617invoke com.raycloud.template.api.IHaibaoService.querySystemPoster( { \"haibaoUser\": { \"appKey\":\"21470813\", \"subAppKey\":\"44782\", \"class\":\"com.raycloud.template.api.domain.HaibaoUser\" }, \"pageNo\":\"1\", \"pageSize\":\"10\", \"orderBy\":\"defaultOrder\", \"desc\":\"true\", \"imageGroupType\":\"PRICE_WATERMARK\", \"class\":\"com.raycloud.template.api.domain.request.SystemPosterRequest\" }) 多个请求参数12345678910111213ImageResponse queryHaibaoById(HaibaoUser haibaoUser, String imageId, String type);``` ```javainvoke com.raycloud.template.api.IHaibaoService.queryHaibaoById( { \"appKey\":\"12011554\", \"subAppKey\":\"32644\", \"class\":\"com.raycloud.template.api.domain.HaibaoUser\" }, \"3613\", \"sm\")","link":"/2019/08/01/Dubbo-dubbo invoke的使用/"},{"title":"Java-JDK与CGLIB动态代理的实现","text":"动态代理技术可用于运行期动态织入目标方法 JDK动态代理1234567891011121314151617181920212223242526272829303132333435public interface SayService { void say(String name);}public class SayServiceImpl implements SayService { @Override public void say(String name) { System.out.println(name); }}public class DynamicProxy implements InvocationHandler { private Object target; public DynamicProxy(Object target) { this.target = target; } //生成代理对象 public &lt;T&gt; T getProxy(){ return (T) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\"代理前\"); //这里用的target而非方法参数的proxy Object obj = method.invoke(target, args); System.out.println(\"代理后\"); return obj; }} 编写测试方法1234567891011121314151617181920212223242526272829303132333435363738public class JDKProxyTest { public static void main(String[] args) { SayService sayService = new SayServiceImpl(); SayService proxy = new DynamicProxy(sayService).getProxy(); proxy.say(\"changjie\"); //将jdk中生成代理类输出到本地.Class文件，之后可以通过反编译软件打开查看 createProxyClassFile(\"SayService\",sayService.getClass().getInterfaces()); } private static void createProxyClassFile(String name, Class&lt;?&gt; [] interfaces){ //该方法为jdk中生成代理类的核心方法 byte[] data = ProxyGenerator.generateProxyClass(name,interfaces); FileOutputStream out =null; try { out = new FileOutputStream(name+\".class\"); System.out.println((new File(name)).getAbsolutePath()); out.write(data); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); }finally { if(null!=out){ try { out.close(); } catch (IOException e) { e.printStackTrace(); } } } }} 输出1234代理前changjie代理后/Users/admin/IdeaProjects/spring-note/SayService 反编译其生成的动态代理类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public final class SayService extends Proxy implements me.changjie.aop.proxy.SayService { private static Method m1; private static Method m2; private static Method m3; private static Method m0; public SayService(InvocationHandler var1) throws { super(var1); } public final boolean equals(Object var1) throws { try { return (Boolean)super.h.invoke(this, m1, new Object[]{var1}); } catch (RuntimeException | Error var3) { throw var3; } catch (Throwable var4) { throw new UndeclaredThrowableException(var4); } } public final String toString() throws { try { return (String)super.h.invoke(this, m2, (Object[])null); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } public final void say(String var1) throws { try { //调用父类Proxy持有的InvocationHandle对象的invoke方法 super.h.invoke(this, m3, new Object[]{var1}); } catch (RuntimeException | Error var3) { throw var3; } catch (Throwable var4) { throw new UndeclaredThrowableException(var4); } } public final int hashCode() throws { try { return (Integer)super.h.invoke(this, m0, (Object[])null); } catch (RuntimeException | Error var2) { throw var2; } catch (Throwable var3) { throw new UndeclaredThrowableException(var3); } } static { try { m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", Class.forName(\"java.lang.Object\")); m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\"); m3 = Class.forName(\"me.changjie.aop.proxy.SayService\").getMethod(\"say\", Class.forName(\"java.lang.String\")); m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\"); } catch (NoSuchMethodException var2) { throw new NoSuchMethodError(var2.getMessage()); } catch (ClassNotFoundException var3) { throw new NoClassDefFoundError(var3.getMessage()); } }} 可知JDK通过多态和反射生成的动态代理类，生成的代理类继承了Proxy类(持有InvocationHandler对象)，实现了与被代理类相同的接口，这里也能反映出为什么JDK只能代理实现了接口的类，因为生成的代理类需要继承Proxy，由于单继承限制，只能和被代理类实现相同的接口来达到兄弟关系 CGLIB动态代理1234567891011121314151617181920212223242526public class CglibProxyTest { public static void main(String[] args) { Enhancer enhancer = new Enhancer(); ////设置增强类的父类 enhancer.setSuperclass(SayServiceImpl.class); //设置拦截器，拦截对父类所有非final方法的调用 enhancer.setCallback(new MethodInterceptor() { @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { System.out.println(o.getClass().getName()); System.out.println(\"cglib动态代理before\"); //调用父类方法 Object object = methodProxy.invokeSuper(o, objects); System.out.println(\"cglib动态代理after\"); return object; } }); //创建动态代理对象 SayService sayService = (SayService) enhancer.create(); System.out.println(sayService.getClass().getName()); sayService.say(\"changjie\"); }} CGLIB是生成目标类的子类，来织入目标类方法，所以对于final修饰的方法无法代理 总结JDK生成的动态代理类与被代理类是兄弟关系，二者实现了相同接口，所以只能对实现了接口的类进行代理CGLIB生成的代理类与被代理类是父子关系，所以无法对final修饰的方法进行代理","link":"/2019/02/19/Java-JDK与CGLIB的动态代理实现/"},{"title":"Java-集合操作常见的ConcurrentModificationException","text":"用增强循环操作集合元素时通常都会抛出ConcurrentModificationException 普通for循环删除指定元素1234567891011121314List&lt;String&gt; userNames = new ArrayList&lt;String&gt;() {{ add(\"Hollis\"); add(\"hollis\"); add(\"HollisChuang\"); add(\"H\");}};for (int i = 0; i &lt; userNames.size(); i++) { if(userNames.get(i).equalsIgnoreCase(\"hollis\")){ userNames.remove(i); }}System.out.println(userNames); 1[hollis, HollisChuang, H] 只删除了第一个元素，原因比较简单：删除了元素涉及元素移动，i++跳过了后面的元素解决办法是倒着遍历或者使用迭代器遍历 增强for循环删除元素12345for(String name : userNames){ if(name.equalsIgnoreCase(\"hollis\")){ userNames.remove(name); }} 1234Exception in thread \"main\" java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909) at java.util.ArrayList$Itr.next(ArrayList.java:859) at com.raycloud.report.collection.controller.MainTest.main(MainTest.java:27) 在增强for循环中使用add方法添加元素，结果也会同样抛出该异常之所以会出现这个异常，是因为触发了一个Java集合的错误检测机制——fail-fast 对增强for循环语法糖进行解糖12345678Iterator var2 = userNames.iterator();while(var2.hasNext()) { String name = (String)var2.next(); if (name.equalsIgnoreCase(\"hollis\")) { userNames.remove(name); }} 反编译可看出其是由迭代器遍历实现直接运行解糖的代码 123456789101112131415public E next() { checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i];}final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException();} 可知next方法会校验这两个值，这两个值不相等时就会抛出并发修改异常 modCount是ArrayList中的一个成员变量。它表示该集合实际被修改的次数。调用集合的add和remove函数都会使该值加1 expectedModCount 是 ArrayList中的一个内部类——Itr中的成员变量。expectedModCount表示这个迭代器期望该集合被修改的次数。其值是在ArrayList.iterator方法被调用的时候初始化的。只有通过迭代器对集合进行操作，该值才会改变 上图中remove使用的是userNames.remove(name)集合的remove函数1234567891011121314public E remove(int index) { rangeCheck(index); modCount++;//+1 E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;} 集合的remove只操作了modCount值，expectedModCount并没有改变，所以在下一次next时就会不一致，抛出并发修改异常 解决办法 使用迭代器的remove函数1234567Iterator iterator = userNames.iterator();while (iterator.hasNext()) { if (iterator.next().equals(\"Hollis\")) { iterator.remove(); }} 1234567891011121314public void remove() { if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try { ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount;//迭代器的remove会使两个值相等 } catch (IndexOutOfBoundsException ex) { throw new ConcurrentModificationException(); }} 使用Java 8中提供的filter过滤 1userNames = userNames.stream().filter(userName -&gt; !userName.equals(\"Hollis\")).collect(Collectors.toList()); 使用增强for循环也可以，remove后直接退出，也就不会再次调用next方法 123456for (String userName : userNames) { if (userName.equals(\"Hollis\")) { userNames.remove(userName); break; }} 使用迭代器怎么添加元素Iterator迭代器没有添加功能，可使用其子接口ListIterator12345678910ListIterator var2 = userNames.listIterator();while(var2.hasNext()) { String name = (String)var2.next(); if (name.equalsIgnoreCase(\"hollis\")) { var2.add(\"cccc\"); }}System.out.println(userNames); 1[Hollis, cccc, hollis, cccc, HollisChuang, H]","link":"/2019/03/12/Java-集合操作常见的ConcurrentModificationException/"},{"title":"Java基础-Java中对象和引用的关系","text":"1Animal an = new Animal(); 创建一个对象，细化这个动作为: 右面的”new Animal”，在堆空间里创建一个Animal对象 左面的”Animal an” 创建了一个Animal类的一个引用变量 “=” 操作符使对象引用指向刚才创建的那个Animal对象 等同于12Animal an;an = new Animal(); 有两个实体：一个是对象引用变量；一个是对象本身 对象和引用的区别 关联性： 当对象的引用变量指向对象时，两者就互相联系起来，改变引用的属性，就会改变对象的属性 如果同一个对象被多个引用变量引用的话，则这些引用变量将共同影响这个对象本身 在java中，都是通过引用来操纵对象的 差异性： 一个对象可以被不同的引用变量来操纵，同时一个引用变量也可以指向不同的对象，但是同一时刻下只能指向一个对象 从存储空间上来看，对象和引用也是相互独立的，对象一般存储在堆中，而引用存储在堆栈中（存储速度而更快)","link":"/2018/10/17/Java基础-Java中对象和引用的理解/"},{"title":"Java基础-java只有值传递","text":"Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容 example1123456789101112131415161718public static void main(String[] args) { int num1 = 10; int num2 = 20; swap(num1, num2); System.out.println(\"num1 = \" + num1); System.out.println(\"num2 = \" + num2);}public static void swap(int a, int b) { int temp = a; a = b; b = temp; System.out.println(\"a = \" + a); System.out.println(\"b = \" + b);} 1234a = 20b = 10num1 = 10num2 = 20 解析在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身 一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样 example21234567891011public static void main(String[] args) { int[] arr = { 1, 2, 3, 4, 5 }; System.out.println(arr[0]); change(arr); System.out.println(arr[0]);}public static void change(int[] array) { // 将数组的第一个元素变为0 array[0] = 0;} 1210 解析array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。 example3123456789101112131415public static void main(String[] args) { Student s1 = new Student(\"小张\"); Student s2 = new Student(\"小李\"); swap(s1, s2); System.out.println(\"s1:\" + s1.getName()); System.out.println(\"s2:\" + s2.getName());}public static void swap(Student x, Student y) { Student temp = x; x = y; y = temp; System.out.println(\"x:\" + x.getName()); System.out.println(\"y:\" + y.getName());} 1234x:小李y:小张s1:小张s2:小李 解析交换前s1和其副本x指向同一个元素，s2和y指向的是同一个元素交换后s1指针没变，其副本x指针变了，s2指针没变，其副本y指针变了其实交换的其两个副本的指针，原对象指针不受影响 参考链接 为什么 Java 中只有值传递","link":"/2018/10/09/Java基础-java只有值传递/"},{"title":"Java基础-servlet与jsp","text":"servlet在Java Web程序中，Servlet主要负责接收用户请求HttpServletRequest,在doGet(),doPost()中做相应的处理，并将回应HttpServletResponse反馈给用户Servlet可以设置初始化参数，供Servlet内部使用一个Servlet类只会有一个实例，在它初始化时调用init()方法，销毁时调用destroy()方法Servlet需要在web.xml中配置，一个Servlet可以设置多个URL访问Servlet不是线程安全，因此要谨慎使用类变量 servlet生命周期Web容器加载Servlet并将其实例化后，Servlet生命周期开始容器运行其init()方法进行Servlet的初始化请求到达时调用Servlet的service()方法，service()方法会根据需要调用与请求对应的doGet或doPost等方法当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的destroy()方法init方法和destory方法只会执行一次，service方法客户端每次请求Servlet都会执行 转发和重定向转发是服务端行为，重定向是客户端行为转发（Forword）：通过RequestDispatcher对象的forward方法实现的。RequestDispatcher可以通过HttpServletRequest 的getRequestDispatcher()方法获得。例如下面的代码就是跳转到login_success.jsp页面1request.getRequestDispatcher(\"login_success.jsp\").forward(request, response); 重定向（Redirect)：是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过HttpServletRequestResponse的setStatus(int status)方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源 jsp与servletServlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。可以理解为Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller） jsp工作原理JSP是一种Servlet，但是与HttpServlet的工作方式不太一样。HttpServlet是先由源代码编译为class文件后部署到服务器下，为先编译后部署。而JSP则是先部署后编译。JSP会在客户端第一次请求JSP文件时被编译为HttpJspPage类（接口Servlet的一个子类）。该类会被服务器临时存放在服务器工作目录里面。第一次部署到服务器上后访问这个Jsp文件，这个目录下会生成class文件。这个class文件便是JSP对应的Servlet。编译完毕后再运行class文件来响应客户端请求。以后客户端访问login.jsp的时候，Tomcat将不再重新编译JSP文件，而是直接调用class文件来响应客户端请求。JSP是在请求的时候被编译 ，因此第一次请求JSP时会感觉比较慢，之后就会感觉快很多。如果把服务器保存的class文件删除，服务器也会重新编译JSP cookie和session 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session。典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。 思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。 Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。 所以，总结一下：Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式 原文链接 J2EE基础知识","link":"/2018/10/09/Java基础-servlet与jsp/"},{"title":"Java基础-equals与hashcode","text":"equals方法euqals()作为Object的方法，用于判断两个对象是否相等123public boolean equals(Object obj) { return (this == obj);} 很明显是对两个对象的地址值进行的比较（即比较引用是否相同）。像String 、Math、Integer、Double等这些封装类已经将其重写了，比较的是内容 hashcode方法hashCode()也是Object的方法，用于给对象返回一个hash code值。这个方法被用于hash tables，例如HashMap1public native int hashCode(); 是一个本地方法，它的实现是根据本地机器相关,像String 、Math、Integer、Double等这些封装类已经将其重写了 hashcode作用对于java中的set集合元素是不可重复的，元素是否重复通过equals方法判断。但是，如果每增加一个元素就检查一次，那么当元素很多时，比较的次数就非常多了。这显然会大大降低效率。于是，Java采用了哈希表的原理。哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。简而言之，在集合查找时，hashcode能大大降低对象比较次数，提高查找效率 规定Java对象的eqauls方法和hashCode方法是这样规定的：1、相等（相同）的对象必须具有相等的哈希码（或者散列码）。由于HashMap不允许存放重复元素，所以相同元素的hashcode必须不同所以重写了equals的话必须重写hashcode2、如果两个对象的hashCode相同，它们并不一定相同。不同对象的hashcode可能会相同，即会产生哈希冲突 哈希冲突假如两个Java对象A和B，A和B不相等（eqauls结果为false），但A和B的哈希码相等，将A和B都存入HashMap时会发生哈希冲突，也就是A和B存放在HashMap内部数组的位置索引相同这时HashMap会在该位置建立一个链表，将A和B串起来放在该位置，显然，该情况不违反HashMap的使用原则，是允许的。当然，哈希冲突越少越好，尽量采用好的哈希算法以避免哈希冲突 原文链接 Java提高篇——equals()与hashCode()方法详解","link":"/2018/10/09/Java基础-equals与hashcode/"},{"title":"Java基础-static关键字","text":"static关键字主要用于下面几种场景 修饰成员变量和成员方法被 static 修饰的成员变量属于类，不属于单个这个类的某个对象，被类中所有对象共享，建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量存放在 Java 内存区域的方法区。方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。HotSpot 虚拟机中方法区也常被称为 “永久代”，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但这样更容易遇到内存溢出问题 修饰静态块静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。 该类不管创建多少对象，静态代码块只执行一次由于静态代码块只执行一次，其实这里也可以去实现单例模式，本质上和饿汉模式一样，实例初始化过早，一般不建议使用 修饰内部类(只能修饰内部类)静态内部类与非静态内部类之间存在一个最大的区别：非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外部类，但是静态内部类却没有所以静态内部类的创建不需要依赖外部类的创建，也不能使用外部类的非static成员变量和方法(非静态内部类可直接使用外部类的所有(包括私有)属性和方法)静态内部类比较常见的是实现线程安全的单例模式123456789101112131415public class Singleton { //声明为 private 避免调用默认构造方法创建对象 private Singleton() { } //声明为 private 表明静态内部该类只能在外部类中被访问 private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } public static Singleton getUniqueInstance() { return SingletonHolder.INSTANCE; }} 当 外部类加载时，静态内部类并没有被加载进内存。只有当调用 getUniqueInstance()方法从而触发 SingletonHolder.INSTANCE 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持 原文链接 static 关键字","link":"/2018/10/10/Java基础-static关键字/"},{"title":"Java基础-Transient关键字的使用","text":"transient的使用对象实现了序列化接口时，这个类所有属性和方法都可以序列化和被反序列化，当我们不想序列化某些属性时，使用transient修饰这些属性即可，比如对于一些敏感信息(密码，银行卡号等)不希望在网络中传输 传统序列化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class TransientTest { public static class User implements Serializable{ private String username; private String password; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } public static void main(String[] args) { User user = new User(); user.setUsername(\"chang\"); user.setPassword(\"123456\"); System.out.println(\"read before Serializable: \"); System.out.println(\"username: \" + user.getUsername()); System.out.println(\"password: \" + user.getPassword()); try { ObjectOutputStream os = new ObjectOutputStream( new FileOutputStream(\"/Users/admin/Desktop/user.txt\")); os.writeObject(user); // 将User对象写进文件 os.flush(); os.close(); } catch (Exception e) { e.printStackTrace(); } try { ObjectInputStream is = new ObjectInputStream(new FileInputStream( \"/Users/admin/Desktop/user.txt\")); user = (User) is.readObject(); // 从流中读取User的数据 is.close(); System.out.println(\"\\nread after Serializable: \"); System.out.println(\"username: \" + user.getUsername()); System.out.println(\"password: \" + user.getPassword()); } catch (Exception e) { e.printStackTrace(); } }} 输出1234567read before Serializable: username: changpassword: 123456read after Serializable: username: changpassword: 123456 使用transient修饰不想被序列化的字段1private transient String password; 输出1234567read before Serializable: username: changpassword: 123456read after Serializable: username: changpassword: null 密码字段为null，说明反序列化时根本没有从文件中获取到信息 静态变量不管是否被transient修饰，均不能被序列化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class TransientTest { public static class User implements Serializable{ private static final long serialVersionUID = 7195941599855555739L; private String username; private static String password; public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } public static void main(String[] args) { User user = new User(); user.setUsername(\"chang\"); user.setPassword(\"123456\"); System.out.println(\"read before Serializable: \"); System.out.println(\"username: \" + user.getUsername()); System.out.println(\"password: \" + user.getPassword()); try { ObjectOutputStream os = new ObjectOutputStream( new FileOutputStream(\"/Users/admin/Desktop/user.txt\")); os.writeObject(user); // 将User对象写进文件 os.flush(); os.close(); } catch (Exception e) { e.printStackTrace(); } try { User.password = \"1111\";//在反序列化之前修改了静态变量的值 ObjectInputStream is = new ObjectInputStream(new FileInputStream( \"/Users/admin/Desktop/user.txt\")); user = (User) is.readObject(); // 从流中读取User的数据 is.close(); System.out.println(\"\\nread after Serializable: \"); System.out.println(\"username: \" + user.getUsername()); System.out.println(\"password: \" + user.getPassword()); } catch (Exception e) { e.printStackTrace(); } }} 输出1234567read before Serializable: username: changpassword: 123456read after Serializable: username: changpassword: 1111 可知反序列化后类中静态变量的值为当前JVM中对应static变量的值，而不是序列化时的值 ArrayList的实现ArrayList实现了List和Serializable接口，内部由elementData数组实现，1234567891011121314private transient Object[] elementData;private int size;public ArrayList(int var1) { if (var1 &lt; 0) { throw new IllegalArgumentException(\"Illegal Capacity: \" + var1); } else { this.elementData = new Object[var1]; }}public ArrayList() { this(10);} 可知数组的初始化容量是10，每插入一个元素时都要进行最大容量判断123456789101112131415161718public boolean add(E var1) { this.ensureCapacity(this.size + 1);//扩容校验 this.elementData[this.size++] = var1;//将插入的值放到尾部 return true;}public void ensureCapacity(int var1) { ++this.modCount; int var2 = this.elementData.length; if (var1 &gt; var2) {//超过容量需要进行Arrays.copyOf扩容 Object[] var3 = this.elementData; int var4 = var2 * 3 / 2 + 1; if (var4 &lt; var1) { var4 = var1; } this.elementData = Arrays.copyOf(this.elementData, var4); }} 指定位置插入元素的实现12345678910public void add(int var1, E var2) { if (var1 &lt;= this.size &amp;&amp; var1 &gt;= 0) { this.ensureCapacity(this.size + 1);//扩容校验 System.arraycopy(this.elementData, var1, this.elementData, var1 + 1, this.size - var1);//将指定位置后面的元素后移 this.elementData[var1] = var2;//添加到指定位置 ++this.size; } else { throw new IndexOutOfBoundsException(\"Index: \" + var1 + \", Size: \" + this.size); }} 由此可见 ArrayList的主要消耗是数组扩容以及在指定位置添加数据，在日常使用时最好是指定大小，尽量减少扩容。更要减少在指定位置插入数据的操作 ArrayList与transient通过源码得知ArrayList实现了序列化接口并且elementData是被transient修饰的，那不是序列化后的ArrayList丢失了原先的元素？ArrayList内部还有两个方法1234567891011121314151617181920212223private void writeObject(ObjectOutputStream var1) throws IOException { int var2 = this.modCount; var1.defaultWriteObject(); var1.writeInt(this.elementData.length); for(int var3 = 0; var3 &lt; this.size; ++var3) { var1.writeObject(this.elementData[var3]); } if (this.modCount != var2) { throw new ConcurrentModificationException(); }}private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException { var1.defaultReadObject(); int var2 = var1.readInt(); Object[] var3 = this.elementData = new Object[var2]; for(int var4 = 0; var4 &lt; this.size; ++var4) { var3[var4] = var1.readObject(); }} 为什么不直接用elementData来序列化，而采用上述的方式来实现序列化呢？原因在于elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间 原文链接 Java transient关键字使用小记ArrayList中elementData为什么被transient修饰?","link":"/2018/09/30/Java基础-transient的作用与使用/"},{"title":"Java基础-内部类中调用外部局部变量为何用final修饰","text":"在平时写代码中经常会在方法中起一个线程，但是在局部内部类中使用外部局部变量的话编译器会提示将外部局部变量定义为final类型，这是为什么呢12345678910111213public void test(final String a, String b){ new Thread(new Runnable() { @Override public void run() { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \":\"+a); } }).start();} 在局部内部类可以访问方法的形参或局部变量从程序设计语言的理论上:局部内部类(即:定义在方法中的内部类),由于本身就是在方法内部,因而可以访问方法中的局部变量(形式参数或局部变量) 怎么解决局部变量的生命周期与局部内部类的对象的生命周期的不一致当在内部类试图访问外部方法中的局部变量时，外部方法的局部变量很可能已经不存在了，那么就得延续其生命，拷贝到内部类中，而拷贝会带来不一致性，从而需要使用final声明保证一致性。 java8的优化1.8之前在局部内部类使用外部局部变量的话，需要将外部局部变量显式定义为final类型，不然编译期就会提示出错1.8就不需要显式定义为final类型了，但是如果试图改变外部的局部变量引用的话，就会提示需要定义为final类型，其实是语法糖带来的效果 总结复制保证生命周期延续，final保证引用一致 参考链接 为什么匿名内部类参数必须为final类型为在jdk1.8以前匿名内部类使用外部类变量必须是final的原因","link":"/2018/10/10/Java基础-内部类调用局部参数为何用final关键字/"},{"title":"Java集合-List之ArrayList","text":"ArrayList 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长1transient Object[] elementData; transient作用是为了序列化时只序列化数组内的实际元素 源码分析 属性 12345transient Object[] elementData;//保存ArrayList数据的数组private static final int DEFAULT_CAPACITY = 10;//缺省容量private static final Object[] EMPTY_ELEMENTDATA = {};//空对象数组private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};//缺省空对象数组private int size;//实际元素大小，默认为0 构造方法 12345678910111213141516171819202122232425public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;//并不会真正产生实例化的数组，而是引用一个静态的空数组}public ArrayList(int initialCapacity) { if (initialCapacity &gt; 0) { this.elementData = new Object[initialCapacity];//创建指定大小的数组 } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA;//并不会真正产生实例化的数组，而是引用一个静态的空数组 } else { throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); }}public ArrayList(Collection&lt;? extends E&gt; c) { elementData = c.toArray();//转成数组 if ((size = elementData.length) != 0) {//数组不为空 // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class);//数组拷贝生成新数组对象 } else { // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; }} add方法 1234567891011121314151617181920212223242526272829303132public boolean add(E e) { ensureCapacityInternal(size + 1); // 扩容判断 elementData[size++] = e;//添加到末尾 return true;}private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));}private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity);//使用无参构造实例化时，引用的是空数组，添加第一个元素这里扩展成默认容量10 } return minCapacity;}private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);//扩容}private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length;//旧容量 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//新容量扩成原来的1.5倍 右移n就是除以2的n次方 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity;//扩到1.5倍还不够的话，一步到位 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity);//最大容量判断 // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);//拷贝} addAll方法 12345678public boolean addAll(Collection&lt;? extends E&gt; c) { Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); //先扩容 System.arraycopy(a, 0, elementData, size, numNew);//将目标数组元素全部拷贝到原元素组后面 size += numNew; return numNew != 0;} remove方法 123456789101112131415161718192021222324252627282930313233343536373839404142//根据索引位置去删除public E remove(int index) { rangeCheck(index);//检查索引是否合法 modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved);//从指定位置后面往前复制 elementData[--size] = null; //赋值为空，有利于进行GC return oldValue;//返回旧值}//根据元素内容去删除public boolean remove(Object o) { if (o == null) {//可以看出Arraylist允许元素为null for (int index = 0; index &lt; size; index++) if (elementData[index] == null) { fastRemove(index); return true; } } else { for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) { fastRemove(index);//先找到元素位置，在根据索引位置去删除 return true; } } return false;}private void fastRemove(int index) { modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work} get方法 12345public E get(int index) { rangeCheck(index); return elementData(index);} 减少扩容次数在创建ArrayList之前知道要插入的对象的数目的话，直接使用有参构造即可当创建ArrayList之后知道要插入的对象的数目的话，最好提前扩容，不然每添加到一定元素就需要扩容拷贝，可调用ensureCapacity(int minCapacity)方法扩容一次即可，来提高效率12345678910111213//扩容到可容纳minCapacitypublic void ensureCapacity(int minCapacity) { int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) { ensureExplicitCapacity(minCapacity); }} ArrayList与数组的区别既然ArrayList内部由数组实现,那二者有什么区别呢？ 数组可存放基本类型和对象类型，而ArrayList只可存放对象类型 ArrayList提供了更丰富的api操作 Arraylist大小是动态变化的，Array定长","link":"/2018/10/10/Java集合-List之ArrayList/"},{"title":"Mysql-key_len的计算","text":"当用Explain查看SQL的执行计划时，里面有列显示了 key_len 的值，根据这个值可以判断索引的长度，在组合索引里面可以更清楚的了解到了哪部分字段使用到了索引 建表123456CREATE TABLE student ( id int(11) AUTO_INCREMENT primary key , name varchar(10) DEFAULT NULL, cid int(11) DEFAULT NULL, created timestamp) ENGINE=InnoDB DEFAULT CHARSET=utf8; 索引12alter table student drop index index_name_cid_created;alter table student add index index_name_cid_created (name, cid, created); 执行计划1EXPLAIN SELECT * FROM student WHERE name = 'aaaa' and cid = 1 and created &gt; '2018-11-11 11:11:11'; MySQL 字段类型占用空间常用类型存储需求完整对应链接 类型 存储空间 TINYINT 1个字节 SMALLINT 2个字节 INT, INTEGER 4个字节 BIGINT 8个字节 DATE 3个字节 DATETIME 8个字节 TIMESTAMP 4个字节 CHAR(M) 3M个字节，0 &lt;= M &lt;= 255 VARCHAR(M) 2+3M，0 &lt;= M &lt;= 65535 int（10）这里的10指的是数值的宽度，并不是字节数，如果使用了zerofill，当结果小于显示宽度时，左边用0补齐，当等于或超过显示宽度时正常显示，没啥用char(20)、varchar(20)，20指的是字符而不是字节（4.0版本以上，以下指的是字节）字符和字节的转换要看字符集，utf-8下，1字符=3字节；gbk下，1字符=2字节 结果分析 此时索引长度是42个字节由于表的字符集是utf8, 1char=3byte，10 * 3=30由于varchar是变长类型，需要额外的2个字节，固定长度字段(char,int)不需要额外的字节由于字段默认为null，所以需要1个字节的额外空间(30 + 2 + 1) + (4 + 1) + 4 = 42 最左前缀原则对于联合索引mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整","link":"/2018/11/09/Mysql-key_len的计算/"},{"title":"Java集合-List之LinkedList","text":"LinkedList底层的链表结构使它支持高效的插入和删除操作，另外它实现了Deque接口，使得LinkedList类也具有队列的特性1234567891011private static class Node&lt;E&gt; { E item;//节点值 Node&lt;E&gt; next;//前驱节点 Node&lt;E&gt; prev;//后继节点 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) { this.item = element; this.next = next; this.prev = prev; }} 源码分析 属性 123transient int size = 0;//链表的元素个数transient Node&lt;E&gt; first;//头节点transient Node&lt;E&gt; last;//尾节点 构造方法 123456public LinkedList() {}public LinkedList(Collection&lt;? extends E&gt; c) { this();//调用无参构造方法 addAll(c);//添加元素} addFirst：将元素插入到最前面 1234567891011121314public void addFirst(E e) { linkFirst(e);}private void linkFirst(E e) { final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f);//创建新元素,前驱节点为null,后继节点为之前的头结点 first = newNode;//将新元素设为头结点 if (f == null) last = newNode; else f.prev = newNode;//将新元素作为原来头结点的前驱节点 size++; modCount++;} addLast/add：将元素插入到最后面 1234567891011121314public void addLast(E e) { linkLast(e);}void linkLast(E e) { final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);//创建新元素,后继节点为null,后继节点为之前的尾结点 last = newNode;//将新元素设为尾结点 if (l == null) first = newNode; else l.next = newNode;//将新元素作为原来尾结点的后继节点 size++; modCount++;} add(int index, E element)：在指定位置插入元素 新节点的前驱为指定位置元素的前驱，新节点的后继指定位置元素指定位置元素的前驱节点的后继设为新元素，指定位置的前驱设为新元素1234567891011121314151617181920public void add(int index, E element) { checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));}void linkBefore(E e, Node&lt;E&gt; succ) { // assert succ != null; final Node&lt;E&gt; pred = succ.prev;//找出指定位置的前驱节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ);//创建新元素，后继元素即为指定位置元素，前驱为指定位置的原前驱 succ.prev = newNode;//将新元素作为指定位置元素的新前驱 if (pred == null) first = newNode; else pred.next = newNode;//将新元素作为指定元素原前驱节点的新后继 size++; modCount++;} removeFirst/remove：删除第一个元素 将头结点的后继节点设为新的头结点，再把新的头结点的前驱设置null removeLast：删除最后一个元素 将最后元素的前驱作为新的尾节点，再把新的尾节点的后继设为null remove(int index)：删除指定位置的元素 先根据索引找到这个节点(从头结点开始找)，再修改这个节点的前驱的后继和后继的前驱即可 remove(Object o)：删除指定内容的元素 先根据内容找到这个节点(从头结点开始找)，再修改这个节点的前驱的后继和后继的前驱即可 总结无论是根据指定索引位置进行查找还是根据指定元素内容进行查找，都需要从头结点进行遍历插入和删除的话只需要操作前驱和后继元素即可","link":"/2018/10/10/Java集合-List之LinkedList/"},{"title":"Java集合-Map之HashMap","text":"JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间 1.8之前底层数据结构JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用。 key经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的时数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。 所谓扰动函数指的就是 HashMap 的 hash 方法。使用扰动函数之后可以减少碰撞 1.8之前的扰动函数1234static int hash(int var0) { var0 ^= var0 &gt;&gt;&gt; 20 ^ var0 &gt;&gt;&gt; 12; return var0 ^ var0 &gt;&gt;&gt; 7 ^ var0 &gt;&gt;&gt; 4;} 1.8扰动函数1234static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);} 相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次 所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可 1.8之后相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间 属性123456789101112131415161718192021222324// 默认的初始容量是16static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 最大容量，超过该容量就不再扩容了static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认的填充因子static final float DEFAULT_LOAD_FACTOR = 0.75f;// 当桶(bucket)上的结点数大于这个值时会转成红黑树static final int TREEIFY_THRESHOLD = 8; // 当桶(bucket)上的结点数小于这个值时树转链表static final int UNTREEIFY_THRESHOLD = 6;// 桶中结构转化为红黑树对应的table的最小大小static final int MIN_TREEIFY_CAPACITY = 64;// 存储元素的数组，总是2的幂次倍transient Node&lt;k,v&gt;[] table; // 存放具体元素的集transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;// 存放元素的个数，注意这个不等于数组的长度。transient int size;// 每次扩容和更改map结构的计数器transient int modCount; // 临界值 当实际大小超过临界值(容量*填充因子)时，会进行扩容int threshold;// 填充因子final float loadFactor; loadFactor填充因子loadFactor填充因子是控制数组存放数据的疏密程度loadFactor越趋近于1，导致临界值越大，越难扩容，数据越密，链表越长，查找效率越低loadFactor越趋近于0，导致临界值越小，越易扩容，数据越散，数组越大，增删效率越低默认值为0.75f是官方给出的一个比较好的临界值。 threshold临界值当实际大小超过临界值(容量 填充因子)时，会进行扩容默认临界值是160.75=12，即超过12个元素时会扩容 扩容因为HashMap为了节省创建出的对象的内存占用，一开始只默认分配16个，超过临界值就会进行扩容，扩大成2倍，容量达到最大值则不再扩容进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize 寻址函数h&amp;(length - 1)寻址函数相当于对数组长度进行取模，而且速度比直接取模快得多，除了取模运算外还有一个非常重要的责任：均匀分布table数据和充分利用空间 数组长度为什么总是2的n次方&amp;运算符：如果相对应位都是1，则结果为1，否则为0在构造函数中存在：capacity &lt;&lt;= 1;这样做总是能够保证HashMap的底层数组长度为2的n次方length为2的幂次方，即一定是偶数，偶数减1，即是奇数，这样保证了（length-1）在二进制中最低位是1，而&amp;运算结果的最低位是1还是0就完全取决于hash值二进制的最低位。如果length为奇数，则length-1则为偶数，则length-1二进制的最低位恒为0，则&amp;位运算的结果最低位恒为0，即恒为偶数。这样table数组就只可能在偶数下标的位置存储了数据，浪费了所有奇数下标的位置，这样也更容易产生hash冲突 1.6源码分析 构造方法12345678910111213141516171819202122232425262728293031323334353637383940//无参public HashMap() { this.entrySet = null; this.loadFactor = 0.75F; this.threshold = 12; this.table = new HashMap.Entry[16];//数组长度 this.init();}//指定数组长度public HashMap(int var1) { this(var1, 0.75F);}//初始化容量和填充因子public HashMap(int var1, float var2) { this.entrySet = null; if (var1 &lt; 0) { throw new IllegalArgumentException(\"Illegal initial capacity: \" + var1); } else { if (var1 &gt; 1073741824) { var1 = 1073741824; } if (var2 &gt; 0.0F &amp;&amp; !Float.isNaN(var2)) { int var3; //保证HashMap的底层数组长度为2的n次方 for(var3 = 1; var3 &lt; var1; var3 &lt;&lt;= 1) { ; } this.loadFactor = var2; this.threshold = (int)((float)var3 * var2); ////初始化table数组，这是HashMap真实的存储容器 this.table = new HashMap.Entry[var3]; //该方法为空实现，主要是给子类去实现 this.init(); } else { throw new IllegalArgumentException(\"Illegal load factor: \" + var2); } }} put 思路：用key的hashcode经过扰动函数和寻址函数找到数组下标，再用头插法插到所在entry的最前面12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 public V put(K var1, V var2) { if (var1 == null) { return this.putForNullKey(var2); } else { //根据key的hashcode获取扰动值 int var3 = hash(var1.hashCode()); //寻址，即对数组长度进行取模,算出所在数组下标 int var4 = indexFor(var3, this.table.length);//遍历数组元素的链表 for(HashMap.Entry var5 = this.table[var4]; var5 != null; var5 = var5.next) { //不同变量的hash值可能会相同 if (var5.hash == var3) { Object var6 = var5.key; //key值存在的话替换value值，返回旧值 if (var5.key == var1 || var1.equals(var6)) { Object var7 = var5.value; var5.value = var2; var5.recordAccess(this); return var7; } } } ++this.modCount; this.addEntry(var3, var1, var2, var4); return null; } } void addEntry(int var1, K var2, V var3, int var4) { HashMap.Entry var5 = this.table[var4];//数组对应的entry //构建新的entry,将原entry作为新entry的next元素,即头插法,插到链表的最前面 this.table[var4] = new HashMap.Entry(var1, var2, var3, var5); if (this.size++ &gt;= this.threshold) { //扩容 this.resize(2 * this.table.length); } } void resize(int var1) { HashMap.Entry[] var2 = this.table; int var3 = var2.length; if (var3 == 1073741824) { this.threshold = 2147483647; } else { //创建一个新的table，长度为之前的两倍 HashMap.Entry[] var4 = new HashMap.Entry[var1];// this.transfer(var4); this.table = var4; //重新计算临界值 this.threshold = (int)((float)var1 * this.loadFactor); } } //通过遍历的方式，将老table的数据，重新寻址并存储到新table的适当位置 void transfer(HashMap.Entry[] var1) { HashMap.Entry[] var2 = this.table; int var3 = var1.length; for(int var4 = 0; var4 &lt; var2.length; ++var4) { HashMap.Entry var5 = var2[var4]; if (var5 != null) { var2[var4] = null; HashMap.Entry var6; do { var6 = var5.next; //重新寻址 int var7 = indexFor(var5.hash, var3); var5.next = var1[var7]; var1[var7] = var5; var5 = var6; } while(var6 != null); } } } get(Object key) 思路：用key的hashcode经过扰动函数和寻址函数找到数组下标，再遍历单向链表12345678910111213141516public V get(Object var1) { if (var1 == null) { return this.getForNullKey(); } else { int var2 = hash(var1.hashCode()); for(HashMap.Entry var3 = this.table[indexFor(var2, this.table.length)]; var3 != null; var3 = var3.next) { if (var3.hash == var2) { Object var4 = var3.key; if (var3.key == var1 || var1.equals(var4)) { return var3.value; } } } return null; } } remove(Object var1)思路：同样用key的hashcode经过扰动函数和寻址函数找到数组下标，再操作单向链表 1234567891011121314151617181920212223242526272829303132333435public V remove(Object var1) { HashMap.Entry var2 = this.removeEntryForKey(var1); return var2 == null ? null : var2.value; } final HashMap.Entry&lt;K, V&gt; removeEntryForKey(Object var1) { int var2 = var1 == null ? 0 : hash(var1.hashCode()); int var3 = indexFor(var2, this.table.length); HashMap.Entry var4 = this.table[var3]; HashMap.Entry var5; HashMap.Entry var6; for(var5 = var4; var5 != null; var5 = var6) { var6 = var5.next; if (var5.hash == var2) { Object var7 = var5.key; if (var5.key == var1 || var1 != null &amp;&amp; var1.equals(var7)) { ++this.modCount; --this.size; if (var4 == var5) { this.table[var3] = var6; } else { var4.next = var6; } var5.recordRemoval(this); return var5; } } var4 = var5; } return var5; } entrySet()EntrySet重写了iterator方法 123456789101112131415161718192021222324public java.util.Map.Entry&lt;K, V&gt; next() { return this.nextEntry();}final HashMap.Entry&lt;K, V&gt; nextEntry() { if (HashMap.this.modCount != this.expectedModCount) { throw new ConcurrentModificationException(); } else { HashMap.Entry var1 = this.next; if (var1 == null) { throw new NoSuchElementException(); } else { // 如果遍历到table单向链表的最后一个元素时 if ((this.next = var1.next) == null) { HashMap.Entry[] var2 = HashMap.this.table; //继续往下寻找table上有元素的下标 while(this.index &lt; var2.length &amp;&amp; (this.next = var2[this.index++]) == null) { ; } } this.current = var1; return var1; } }} 可知，HashMap的遍历，是依次遍历table上每一条单向链表，这不是插入的顺序，所以说：HashMap是无序的 key为null的处理 key为null的put其实就是放在table[0]的链表里 123456789101112131415private V putForNullKey(V var1) { for(HashMap.Entry var2 = this.table[0]; var2 != null; var2 = var2.next) { if (var2.key == null) { Object var3 = var2.value; var2.value = var1; var2.recordAccess(this); return var3; } } ++this.modCount; //插入到table[0]上单向链表的头部 this.addEntry(0, (Object)null, var1, 0); return null; } key为null的get其实就是遍历table[0]的单向链表 123456789private V getForNullKey() { for(HashMap.Entry var1 = this.table[0]; var1 != null; var1 = var1.next) { if (var1.key == null) { return var1.value; } } return null; } 所以，在HashMap中，不允许key重复，而key为null的情况，只允许一个key为null的Entry，并且存储在table[0]的单向链表上 总结 HashMap是基于哈希表实现的，用Entry[]来存储数据，而Entry中封装了key、value、hash以及Entry类型的next HashMap存储数据是无序的 hash冲突是通过拉链法解决的 HashMap的容量永远为2的幂次方，有利于哈希表的散列 HashMap不支持存储多个相同的key，且只保存一个key为null的值，多个会覆盖 put过程，是先通过key算出hash，然后用hash算出应该存储在table中的index，然后遍历table[index]，看是否有相同的key存在，存在，则更新value；不存在则插入到table[index]单向链表的表头，时间复杂度为O(n) get过程，通过key算出hash，然后用hash算出应该存储在table中的index，然后遍历table[index]，然后比对key，找到相同的key，则取出其value，时间复杂度为O(n) HashMap是线程不安全的，如果有线程安全需求，推荐使用ConcurrentHashMap 参考链接 图解HashMap原理","link":"/2018/10/12/Java集合-Map之HashMap/"},{"title":"Mysql-存储过程生成测试数据","text":"在进行查询操作的性能测试时，往往需要测试大数据量模式下的查询功能的性能MySQL表数据量的大小，也会影响索引的选择 随机函数123456789101112CREATE DEFINER=`root`@`%` FUNCTION `rand_string`(n INT) RETURNS varchar(255) CHARSET utf8mb4 DETERMINISTICBEGIN DECLARE chars_str varchar(100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; DECLARE return_str varchar(255) DEFAULT '' ; DECLARE i INT DEFAULT 0; WHILE i &lt; n DO SET return_str = concat(return_str, substring(chars_str, FLOOR(1 + RAND() * 62), 1)); SET i = i + 1; END WHILE; RETURN return_str;END; 函数说明rand()：用于生成[0,1)之间的随机数substring(str,pos,len)：从字符串第pos个字符开始，截取len个字符concat(str1,str2)：用于字符串拼接可知上面函数是生成指定位数的字符串 存储过程12345678CREATE DEFINER=`root`@`%` PROCEDURE `insert_student`(IN n int)BEGIN DECLARE i INT DEFAULT 1; WHILE (i &lt;= n) DO INSERT INTO student (name, cid) VALUES (rand_string(8), FLOOR(RAND() * 100)); SET i = i + 1; END WHILE;END; 用rand_string函数给name字段生成8位随机字符串，cid字段为[0,100)的整数，随机插入指定条 运行存储过程1CALL insert_student(1000000);","link":"/2018/11/09/Mysql-存储过程生成测试数据/"},{"title":"Mysql-按小时统计数据","text":"Mysql统计一天中每小时数据量sql如下1234567select created, count(created)from ( select DATE_FORMAT( created ,'%Y-%m-%d %H') created from shop_check_result where created &gt; '2018-10-08 00:00:00' and created &lt; '2018-10-09 00:00:00' ) agroup by created;","link":"/2018/10/11/Mysql-按小时统计数据/"},{"title":"Mysql-SQL中过滤条件放在on和where中的区别","text":"在使用多表关联查询时，连接条件放在on和where得到的结果集是不同的 数据准备12select * from person;select * from account; 内连接、全连接1select * from person p inner join account a on p.id=a.id; 内连接的结果集返回交集数据 使用on条件1select * from person p inner join account a on p.id=a.id and p.id!=4; 使用where条件1select * from person p inner join account a on p.id=a.id where p.id!=4; 结果集相同，可知内连接时过滤条件使用在on和where上时作用相同 左连接1select * from person p inner join account a on p.id=a.id; 左连接的结果集返回左表数据，不满足连接条件来自右表字段为空 使用on条件1select * from person p left join account a on p.id=a.id and p.id!=4; id为4的记录还在，这是由left join的特性决定的，使用left join时on后面的条件只对右表有效（可以看到右表的id=4的记录没了） 使用where条件1select * from person p left join account a on p.id=a.id where p.id!=4; 可见id为4的记录没了 总结其实on上的过滤条件就是先对右表数据过滤，再与左表连接，再生成连接中间表where是对中间表进行过滤","link":"/2019/02/12/Mysql-SQL中过滤条件放在on和where中的区别/"},{"title":"Mysql-索引的数据结构","text":"索引能够使每次查找数据时把磁盘IO次数控制在一个很小的数量级Mysql索引的数据结构是b+树 b+树的数据结构浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中 b+树的查找过程如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高 b+树性质通过上面的分析，我们知道磁盘IO次数取决于b+数的高度h，树高越低磁盘IO越少在数据量一定的情况下，为了使树高越低，需要使每个磁盘块存储的数据量越多，而磁盘块的大小也就是一个数据页的大小，是固定的，为了使存储的数据量越多，则需要使索引字段数据项所占的空间越少，所以需要控制字段类型 参考链接 MySQL索引原理及慢查询优化MySQL 索引及查询优化总结","link":"/2018/11/09/Mysql-索引的数据结构/"},{"title":"Mysql-引号对索引的影响","text":"在进行查询操作时，如果对于字符型字段进行where查询不加引号时不会走索引 创建表123456CREATE TABLE `student` ( `id` int(11) AUTO_INCREMENT primary key , `name` varchar(10) DEFAULT NULL, `cid` int(11) DEFAULT NULL, created timestamp) ENGINE=InnoDB DEFAULT CHARSET=utf8; 使用前文存储过程随机插入2000条数据 创建索引1alter table student add index index_name (name); 创建字符型name字段的单列索引 结果对比可见对于字符型name字段加了引号时走了索引，不加引号时不走索引 结论 查询关键字要保证和查询字段类型一致，在类型不一致时MySQL需要进行隐式转换，转换成相同的类型才能进行比较。隐式转换可能会使索引失效，严重影响系统性能。尤其是字段为字符型但是查询关键字没有加引号的情况下，开销相当的巨大 如果类型不一致，有一方为数值行，MySQL会优先转换成数值型 数值类型的查询效率要比字符型高，字符型索引长度较大 如果字段为字符型，查询关键字一定要加上引号 总之要避免隐式转换，隐式转换本身会有系统开销，而且会造成不可预知的影响","link":"/2018/11/09/Mysql-引号对索引的影响/"},{"title":"Spring-Spring Quartz和Task的区别","text":"目前比较常用的定时任务解决方案一般就是Spring Quartz和Task spring-quartzspring-quartz只是spring对quartz的一个包装而已。其实现是在spring-context-support中 特点 默认多线程异步执行 单个任务时，在上一个调度未完成时，下一个调度时间到时，会另起一个线程开始新的调度。业务繁忙时，一个任务会有多个调度，可能导致数据处理异常 多个任务时，任务之间没有直接影响，多任务执行的快慢取决于CPU的性能 使用123456789101112131415161718192021&lt;bean id=\"job\" class=\" xx.xx.xx.Job\" /&gt;&lt;bean id=\"cronTask\" class=\"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean\"&gt; &lt;property name=\"targetObject\" ref=\"job\" /&gt; &lt;property name=\"targetMethod\" value=\"runWork\" /&gt; &lt;!-- false表示job不会并发执行，默认为true--&gt; &lt;property name=\"concurrent\" value=\"false\" /&gt;&lt;/bean&gt;&lt;!—配置触发器--&gt;&lt;bean id=\"doWork\" class=\"org.springframework.scheduling.quartz.CronTriggerBean\"&gt; &lt;property name=\"jobDetail\" ref=\"cronTask\" /&gt; &lt;!—每天凌晨0点1分执行--&gt; &lt;property name=\"cronExpression\" value=\"0 01 00 * * ?\" /&gt;&lt;/bean&gt;&lt;!—最后配置调度工厂--&gt;&lt;bean class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\"&gt; &lt;property name=\"triggers\"&gt; &lt;list&gt; &lt;ref local=\"doWork\"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; spring-taskSpring从3.0开始增加了自己的任务调度器，它是通过扩展java.util.concurrent包下面的类来实现的，也称spring-schedule 特点 默认单线程同步执行 单个任务时，当前次的调度完成后，再执行下一次任务调度 多个任务时，一个任务执行完成后才会执行下一个任务。若需要任务能够并发执行，需手动设置线程池 默认单线程同步执行123456789101112131415161718192021&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:task=\"http://www.springframework.org/schema/task\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.0.xsd\"&gt; &lt;task:annotation-driven /&gt; &lt;bean id=\"myTask\" class=\"me.changjie.task.MyTask\"&gt;&lt;/bean&gt; &lt;!--&lt;task:scheduler id=\"scheduler\" pool-size=\"5\" /&gt;--&gt; &lt;!--&lt;task:scheduled-tasks scheduler=\"scheduler\"&gt;--&gt; &lt;task:scheduled-tasks&gt; &lt;!--两个任务间隔10s执行--&gt; &lt;task:scheduled ref=\"myTask\" method=\"method1\" cron=\"0 33 13 * * ?\" /&gt; &lt;task:scheduled ref=\"myTask\" method=\"method2\" cron=\"10 33 13 * * ?\"/&gt; &lt;/task:scheduled-tasks&gt;&lt;/beans&gt; 1234567891011121314public class MyTask { public void method1() throws InterruptedException { System.out.println(\"method1 execute thread:\"+Thread.currentThread().getName()); System.out.println(\"method1 execute time:\"+new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date())); TimeUnit.SECONDS.sleep(20); } public void method2() { System.out.println(\"method2 execute thread:\"+Thread.currentThread().getName()); System.out.println(\"method2 execute time:\"+new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date())); }} 输出1234method1 execute thread:pool-1-thread-1method1 execute time:2018-10-19 13:33:00method2 execute thread:pool-1-thread-1method2 execute time:2018-10-19 13:33:20 设置线程池使其任务并行 1234567891011121314151617181920&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:task=\"http://www.springframework.org/schema/task\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.0.xsd\"&gt; &lt;task:annotation-driven /&gt; &lt;bean id=\"myTask\" class=\"me.changjie.task.MyTask\"&gt;&lt;/bean&gt; &lt;task:scheduler id=\"scheduler\" pool-size=\"5\" /&gt; &lt;task:scheduled-tasks scheduler=\"scheduler\"&gt; &lt;!--&lt;task:scheduled-tasks&gt;--&gt; &lt;task:scheduled ref=\"myTask\" method=\"method1\" cron=\"0 36 13 * * ?\" /&gt; &lt;task:scheduled ref=\"myTask\" method=\"method2\" cron=\"10 36 13 * * ?\"/&gt; &lt;/task:scheduled-tasks&gt;&lt;/beans&gt; 输出1234method1 execute thread:scheduler-1method1 execute time:2018-10-19 13:36:00method2 execute thread:scheduler-2method2 execute time:2018-10-19 13:36:10 对比易用性 spring-quartz配置较复杂(任务、触发器、调度工厂)，但拥有spring-task所有的功能 spring-task配置较简单，但是默认单线程同步，为了避免任务阻塞，最好配置成线程池异步执行 异常处理 Quartz的某次执行任务过程中抛出异常，不影响下一次任务的执行，当下一次执行时间到来时，定时器会再次执行任务 SpringTask不同，一旦某个任务在执行过程中抛出异常，则整个定时器生命周期就结束，以后永远不会再执行定时器任务，所以最好全范围catch掉","link":"/2018/10/19/Spring-Spring Quartz和Task的区别/"},{"title":"多线程-ThreadPoolExecutor用法","text":"属性1234567int corePoolSize;//核心线程数，默认情况下核心线程会一直存活，即使处于闲置状态也不会受存keepAliveTime限制。除非将allowCoreThreadTimeOut设置为trueint maximumPoolSize//线程池所能容纳的最大线程数。超过这个数的线程将被阻塞。当任务队列为没有设置大小的LinkedBlockingDeque时，这个值无效long keepAliveTime//非核心线程的闲置超时时间，超过这个时间就会被回收TimeUnit unit//指定keepAliveTime的单位BlockingQueue&lt;Runnable&gt; workQueue//线程池中的任务队列，常用的是：ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueueThreadFactory threadFactory//线程工厂，提供创建新线程的功能RejectedExecutionHandler handler//拒绝策略，线程池线程数达到最大值并且任务队列满时触发 方法 getCorePoolSize()：返回核心线程数量，即corePoolSize getPoolSize()：返回当前线程池中线程数，刚创建线程池时线程数为0，直到有任务提交过来才创建线程 getQueue().size()：获取当前任务队列的实际容量 任务队列 SynchronousQueue：直接提交的队列 该任务队列没有容量，新任务总是提交给线程执行，如果活跃线程达到最大值，新任务提交会执行拒绝策略，这种队列会导致线程数过多或太容易触发拒绝策略一般不建议使用 ArrayBlockingQueue：有界任务队列 构造函数必须传容量表示任务队列的最大值新任务提交，若线程池实际线程数小于核心线程数的话会创建线程，等于核心线程数的话会把任务放入队列中，队列满的话创建新的线程，达到最大线程数并且队列满的话执行拒绝策略 LinkedBlockingQueue：无界任务队列 新任务提交，若线程池实际线程数小于核心线程数的话会创建线程，等于核心线程数的话会把任务放入队列中，由于是无界（其实也是有最大值的），队列基本不会满，新任务会一直放入队列中而不会创建新的线程，使用不当会发生内存溢出所以一般会设置个容量，队列满时创建新线程，达到最大线程数并且队列满的话执行拒绝策略 拒绝策略 AbortPolicy：默认拒绝策略，新任务会被拒绝并抛出异常 12345public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { throw new RejectedExecutionException(\"Task \" + r.toString() + \" rejected from \" + e.toString());} DiscardPolicy：直接丢弃被拒绝的任务 12public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {} DiscardOldestPolicy：如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程） 123456public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { if (!e.isShutdown()) { e.getQueue().poll(); e.execute(r); }} CallerRunsPolicy：交由调用者线程来执行任务 12345public void rejectedExecution(Runnable r, ThreadPoolExecutor e) { if (!e.isShutdown()) { r.run(); }}","link":"/2018/10/12/多线程-ThreadPoolExecutor用法/"},{"title":"Spring-徒手撸框架 实现IOC","text":"IOC是什么IoC 不是一种技术，只是一种思想。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用。IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找 IOC有什么用在 Java 中 Everything is Object，我们的程序就是由若干对象组成的。当我们的项目越来越大，合作的开发者越来越多的时候，我们的类就会越来越多，类与类之间的引用就会成指数级的增长。如下图所示：这样的工程简直就是灾难，如果我们引入 Ioc 框架。由框架来维护类的生命周期和类之间的引用。我们的系统就会变成这样： 用一个类比来理解这个问题。IOC框架就是我们生活中的房屋中介，首先中介会收集市场上的房源，分别和各个房源的房东建立联系。当我们需要租房的时候，并不需要我们四处寻找各类租房信息。我们直接找房屋中介，中介就会根据你的需求提供相应的房屋信息。大大提升了租房的效率，减少了你与各类房东之间的沟通次数 Spring 的 IoC 是怎么实现的了解Spring框架最直接的方法就阅读Spring的源码。但是Spring的代码抽象的层次很高，且处理的细节很高。Spirng IoC 主要是以下几个步骤。 初始化 IoC 容器。 读取配置文件。 将配置文件转换为容器识别对的数据结构（这个数据结构在Spring中叫做 BeanDefinition) 利用数据结构依次实例化相应的对象 注入对象之间的依赖关系 自己实现一个IoC框架 定义bean的数据结构 12345678public class BeanDefinition { private String name; private String className; //get set} 工具类 123456789101112131415161718192021222324252627282930313233343536//负责处理 Java 类的加载public class ClassUtils { public static ClassLoader getDefultClassLoader(){ return Thread.currentThread().getContextClassLoader(); } public static Class loadClass(String className) throws ClassNotFoundException { return getDefultClassLoader().loadClass(className); }}//负责处理对象的实例化public class BeanUtils { public static &lt;T&gt; T instanceByCglib(Class&lt;T&gt; clz, Constructor ctr, Object[] args) { Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(clz); enhancer.setCallback(NoOp.INSTANCE); if(ctr == null){ return (T) enhancer.create(); }else { return (T) enhancer.create(ctr.getParameterTypes(),args); } }}//使用反射来完成对象的依赖注入public class ReflectionUtils { public static void injectField(Field field, Object obj, Object value) throws IllegalAccessException { if(field != null) { field.setAccessible(true);//访问私有属性 field.set(obj, value);//设置 obj 的 field 为 value } }} bean工厂 123public interface BeanFactory { Object getBean(String name) throws Exception;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class BeanFactoryImpl implements BeanFactory { private static final ConcurrentHashMap&lt;String,Object&gt; beanMap = new ConcurrentHashMap&lt;&gt;(); private static final ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefineMap= new ConcurrentHashMap&lt;&gt;();//存储的是对象的名称和对象对应的数据结构的映射 private static final Set&lt;String&gt; beanNameSet = Collections.synchronizedSet(new HashSet&lt;&gt;()); @Override public Object getBean(String name) throws Exception { //查找对象是否已经实例化过 Object bean = beanMap.get(name); if(bean != null){ return bean; } //如果没有实例化，那就需要调用createBean来创建对象 bean = createBean(beanDefineMap.get(name)); if(bean != null) { //对象创建成功以后，注入对象需要的参数 populatebean(bean); //再把对象存入Map中方便下次使用。 beanMap.put(name,bean); } //结束返回 return bean; } private Object createBean(BeanDefinition beanDefinition) throws Exception { String beanName = beanDefinition.getClassName(); Class clz = ClassUtils.loadClass(beanName); if(clz == null) { throw new Exception(\"can not find bean by beanName\"); } return BeanUtils.instanceByCglib(clz,null,null); } private void populatebean(Object bean) throws Exception { Field[] fields = bean.getClass().getSuperclass().getDeclaredFields(); if (fields != null &amp;&amp; fields.length &gt; 0) { for (Field field : fields) { String beanName = field.getName(); beanName = StringUtils.uncapitalize(beanName); if (beanNameSet.contains(field.getName())) { Object fieldBean = getBean(beanName); if (fieldBean != null) { ReflectionUtils.injectField(field,bean,fieldBean); } } } } } protected void registerBean(String name, BeanDefinition bd){ beanDefineMap.put(name,bd); beanNameSet.add(name); }} 首先我们看到在 BeanFactory 的实现中有两 HashMap，beanMap 和 beanDefineMap。 beanDefineMap 存储的是对象的名称和对象对应的数据结构的映射。beanMap 用于保存 beanName和实例化之后的对象。 容器初始化的时候，会调用 BeanFactoryImpl.registerBean 方法。把 对象的 BeanDefination 数据结构，存储起来。 当我们调用 getBean() 的方法的时候。会先到 beanMap 里面查找，有没有实例化好的对象。如果没有，就会去beanDefineMap查找这个对象对应的 BeanDefination。再利用DeanDefination去实例化一个对象。 对象实例化成功以后，我们还需要注入相应的参数，调用 populatebean()这个方法。在 populateBean 这个方法中，会扫描对象里面的Field，如果对象中的 Field 是我们IoC容器管理的对象，那就会调用ReflectionUtils.injectField来注入对象。 一切准备妥当之后，我们对象就完成了整个 IoC 流程。最后这个对象放入 beanMap 中,方便下一次使用。 所以我们可以知道 BeanFactory 是管理和生成对象的地方 容器 我们所谓的容器，就是对BeanFactory的扩展，负责管理 BeanFactory。我们的这个IoC 框架使用 Json 作为配置文件，所以我们容器就命名为 JsonApplicationContext12345678910111213141516171819202122public class JsonApplicationContext extends BeanFactoryImpl { private String fileName; public JsonApplicationContext(String fileName) { this.fileName = fileName; } public void init() throws IOException { loadFile(); } private void loadFile() throws IOException { InputStream inputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(fileName); String text = IOUtils.toString(inputStream,\"utf8\"); List&lt;BeanDefinition&gt; beanDefinitions = JSONObject.parseArray(text,BeanDefinition.class); if(CollectionUtils.isNotEmpty(beanDefinitions)) { for (BeanDefinition beanDefinition : beanDefinitions) { registerBean(beanDefinition.getName(), beanDefinition); } } }} 这个容器的作用就是 读取配置文件。将配置文件转换为容器能够理解的 BeanDefination。然后使用 registerBean 方法。注册这个对象。 至此，一个简单版的 IoC 框架就完成 框架的使用三个对象12345678910111213141516171819202122public class Hand { public void waveHand(){ System.out.println(\"挥一挥手\"); }}public class Mouth { public void speak(){ System.out.println(\"say hello world\"); }}public class Robot { //需要注入 hand 和 mouth private Hand hand; private Mouth mouth; public void show(){ hand.waveHand(); mouth.speak(); }} 配置文件1234567891011121314[ { \"name\":\"robot\", \"className\":\"me.changjie.entity.Robot\" }, { \"name\":\"hand\", \"className\":\"me.changjie.entity.Hand\" }, { \"name\":\"mouth\", \"className\":\"me.changjie.entity.Mouth\" }] 测试类123456789public class App { public static void main(String[] args) throws Exception { JsonApplicationContext applicationContext = new JsonApplicationContext(\"application.json\"); applicationContext.init(); Robot aiRobot = (Robot) applicationContext.getBean(\"robot\"); aiRobot.show(); }} 输出12挥一挥手say hello world 可以看到成功为aiRobot 注入了 hand 和 mouth。 至此我们 Ioc 框架开发完成 原文链接 徒手撸框架–实现IoC源码","link":"/2019/02/19/Spring-徒手撸框架 实现IOC/"},{"title":"Spring-Spring的多种模式配置bean","text":"我们通常会采用xml或者注解来配置bean，在前者又分为三类 反射模式 工厂方法模式 静态工厂方法 实例工厂方法 FactoryBean模式 反射模式12345&lt;bean id=\"car1\" class=\"io.github.cc.factoryMethod.Car\"&gt; &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"Honda\"&gt;&lt;/property&gt; &lt;property name=\"price\" value=\"300000\"&gt;&lt;/property&gt;&lt;/bean&gt; 其中反射模式最常见，需要在bean 配置中指明bean object的全类名，Spring利用Java反射机制创建这个bean 工厂方法模式在工厂方法模式中， Spring不会直接利用反射机制创建bean对象， 而是会利用反射机制先找到Factory类，然后利用Factory再去生成bean对象而Factory Mothod方式也分两种，分别是静态工厂方法和实例工厂方法 静态工厂方法12345678910111213141516public class Car { ...}public class CarStaticFactory { private static Map&lt;Integer, Car&gt; map = new HashMap&lt;Integer,Car&gt;(); static{ map.put(1, new Car(1,\"Honda\",300000)); map.put(2, new Car(2,\"Audi\",440000)); map.put(3, new Car(3,\"BMW\",540000)); } //静态方法获取 public static Car getCar(int id){ return map.get(id); }} 1234567&lt;bean id=\"bmwCar\" class=\"me.changjie.domain.CarStaticFactory\" factory-method=\"getCar\"&gt; &lt;constructor-arg value=\"3\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id=\"audiCar\" class=\"me.changjie.domain.CarStaticFactory\" factory-method=\"getCar\"&gt; &lt;constructor-arg value=\"2\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 可以见到，利用静态工厂方法定义bean中class属性不在是bean的全类名， 而是静态工厂的全类名， 而且还需要指定工厂里的 getBean 静态方法名字和参数 实例工厂方法所谓实例工厂方式就是里面的getCar 方法不是静态的， 也就是代表要先实例1个工厂对象， 才能依靠这个工厂对象去获得bean 对象123456789101112131415public class CarInstanceFactory { private Map&lt;Integer, Car&gt; map = new HashMap&lt;Integer,Car&gt;(); public void setMap(Map&lt;Integer, Car&gt; map) { this.map = map; } public CarInstanceFactory(){ } //此处非静态方法，所以工厂需要实例化 public Car getCar(int id){ return map.get(id); }} 1234567891011121314151617181920212223242526272829&lt;bean id=\"carFactory\" class=\"io.github.cc.factoryMethod.CarInstanceFactory\"&gt; &lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"4\"&gt; &lt;bean class=\"io.github.cc.factoryMethod.Car\"&gt; &lt;property name=\"id\" value=\"4\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"Honda\"&gt;&lt;/property&gt; &lt;property name=\"price\" value=\"300000\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/entry&gt; &lt;entry key=\"6\"&gt; &lt;bean class=\"io.github.cc.factoryMethod.Car\"&gt; &lt;property name=\"id\" value=\"6\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"ford\"&gt;&lt;/property&gt; &lt;property name=\"price\" value=\"500000\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;bean id=\"car4\" factory-bean=\"carFactory\" factory-method=\"getCar\"&gt; &lt;constructor-arg value=\"4\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean id=\"car6\" factory-bean=\"carFactory\" factory-method=\"getCar\"&gt; &lt;constructor-arg value=\"6\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 因为实例工厂本身要实例化， 所以我们可以在xml中 指定它里面容器的data Factory Bean模式FactoryBean 用法可以与Factory Method有点类似，我们同样需要写1个工厂类，只不过spring提供了1个叫做FactoryBean的接口我们的工厂类必须实现这个接口12345678910111213141516171819202122232425262728293031public class CarBeanFactory implements FactoryBean&lt;Car&gt;{ private int id; private String brand; public void setId(int id) { this.id = id; } public void setBrand(String brand) { this.brand = brand; } //利用工厂类生产的bean对象， 通常在里面new 1个 对象就ok @Override public Car getObject() throws Exception { return new Car(id, brand, 0); } //指明bean的对象的class @Override public Class&lt;?&gt; getObjectType() { return Car.class; } //bean是否单例 @Override public boolean isSingleton() { return true; }} 1234&lt;bean id=\"esCar\" class=\"me.changjie.domain.CarFactoryBean\"&gt; &lt;property name=\"id\" value=\"111\"&gt;&lt;/property&gt; &lt;property name=\"brand\" value=\"es200\"&gt;&lt;/property&gt;&lt;/bean&gt;","link":"/2019/02/22/Spring-Spring的多种模式配置bean/"},{"title":"Spring-IOC初始化过程","text":"Spring的IOC容器负责管理bean的生命周期 IOC初始化 初始化bean工厂 注册beanDefinition 实例化bean 属性装配 执行回调方法 入口12ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"spring-base.xml\");Student student = (Student) applicationContext.getBean(\"stu1\"); 流程图项目启动时spring会通过资源加载组件(ResourceLoader)加载配置文件(spring-base.xml)作为资源(Resource)通过BeanDefinitonReader解析此资源生成bean定义(beanDefinition)注册到bean工厂(DefaultListableBeanFactory持有一个Map&lt;String, BeanDefiniton&gt;)并完成bean的初始化(实例化、属性装配)执行回调方法从而提供bean的获取 回调方法(AbstractAutowireCapableBeanFactory.initializeBean)123456789101112131415161718192021222324252627282930313233343536protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) { if (System.getSecurityManager() != null) { AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() { @Override public Object run() { invokeAwareMethods(beanName, bean); return null; } }, getAccessControlContext()); } else { invokeAwareMethods(beanName, bean); } Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) { //回调BeanPostProcessor的postProcessBeforeInitialization方法 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); } try { //回调初始化方法afterPropertiesSet invokeInitMethods(beanName, wrappedBean, mbd); } catch (Throwable ex) { throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, \"Invocation of init method failed\", ex); } if (mbd == null || !mbd.isSynthetic()) { //回调BeanPostProcessor的postProcessAfterInitialization方法 wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); } return wrappedBean;} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Overridepublic Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException { Object result = existingBean; //prepareBeanFactory(beanFactory)方法中添加了ApplicationContextAwareProcessor for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) { result = beanProcessor.postProcessBeforeInitialization(result, beanName); if (result == null) { return result; } } return result;}protected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd) throws Throwable { boolean isInitializingBean = (bean instanceof InitializingBean); if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod(\"afterPropertiesSet\"))) { if (logger.isDebugEnabled()) { logger.debug(\"Invoking afterPropertiesSet() on bean with name '\" + beanName + \"'\"); } if (System.getSecurityManager() != null) { try { AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() { @Override public Object run() throws Exception { ((InitializingBean) bean).afterPropertiesSet(); return null; } }, getAccessControlContext()); } catch (PrivilegedActionException pae) { throw pae.getException(); } } else { ((InitializingBean) bean).afterPropertiesSet(); } } if (mbd != null) { String initMethodName = mbd.getInitMethodName(); if (initMethodName != null &amp;&amp; !(isInitializingBean &amp;&amp; \"afterPropertiesSet\".equals(initMethodName)) &amp;&amp; !mbd.isExternallyManagedInitMethod(initMethodName)) { invokeCustomInitMethod(beanName, bean, mbd); } }}@Overridepublic Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName) throws BeansException { Object result = existingBean; for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) { result = beanProcessor.postProcessAfterInitialization(result, beanName); if (result == null) { return result; } } return result;} ApplicationContextAwareProcessor12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788class ApplicationContextAwareProcessor implements BeanPostProcessor { private final ConfigurableApplicationContext applicationContext; /** * Create a new ApplicationContextAwareProcessor for the given context. */ public ApplicationContextAwareProcessor(ConfigurableApplicationContext applicationContext) { this.applicationContext = applicationContext; } //bean初始化方法前回调 @Override public Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException { AccessControlContext acc = null; if (System.getSecurityManager() != null &amp;&amp; (bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware || bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware || bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)) { acc = this.applicationContext.getBeanFactory().getAccessControlContext(); } if (acc != null) { AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() { @Override public Object run() { invokeAwareInterfaces(bean); return null; } }, acc); } else { invokeAwareInterfaces(bean); } return bean; } private void invokeAwareInterfaces(Object bean) { if (bean instanceof Aware) { if (bean instanceof EnvironmentAware) { ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment()); } if (bean instanceof EmbeddedValueResolverAware) { ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver( new EmbeddedValueResolver(this.applicationContext.getBeanFactory())); } if (bean instanceof ResourceLoaderAware) { ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext); } if (bean instanceof ApplicationEventPublisherAware) { ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext); } if (bean instanceof MessageSourceAware) { ((MessageSourceAware) bean).setMessageSource(this.applicationContext); } //可知当bean实现ApplicationContextAware了接口时，实例化bean后会回调其setApplicationContext方法 if (bean instanceof ApplicationContextAware) { ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext); } } } //bean初始化方法后回调 @Override public Object postProcessAfterInitialization(Object bean, String beanName) { return bean; } private static class EmbeddedValueResolver implements StringValueResolver { private final ConfigurableBeanFactory beanFactory; public EmbeddedValueResolver(ConfigurableBeanFactory beanFactory) { this.beanFactory = beanFactory; } @Override public String resolveStringValue(String strVal) { return this.beanFactory.resolveEmbeddedValue(strVal); } }} 初始化bean的回调方式1&lt;bean id=\"exampleInitBean\" class=\"examples.ExampleBean\" init-method=\"init\"/&gt; 123456public class AnotherExampleBean implements InitializingBean { public void afterPropertiesSet() { // do some initialization work }} 1234@PostConstructpublic void init() {} 1234@Bean(initMethod = \"init\")public Foo foo() { return new Foo();}","link":"/2019/02/18/Spring-Spring IOC初始化过程/"},{"title":"设计模式-责任链模式","text":"责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。比如流程审批就是一个很好的例子，只要终端用户提交申请，根据申请的内容信息，自动建立一条责任链，然后就可以开始流转了 定义抽象处理对象123456789101112131415161718192021public abstract class AbstractHander { /** * 下一个节点 */ protected AbstractHander nextHandler; /** * 本节点的处理方法 * @param days */ public abstract void handle(int days); /** * 给本节点设置后继节点 * @param nextHandler */ public void setNextHandler(AbstractHander nextHandler) { this.nextHandler = nextHandler; }} 定义具体处理对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class HandlerA extends AbstractHander { @Override public void handle(int days) { if(days &lt; 5){ System.out.println(\"**条件符合，由A自己处理这个请求\"); }else{ System.out.println(\"##条件不符合，由A转发这个请求到下一个处理者\"); if(nextHandler != null){ nextHandler.handle(days); } } }}public class HandlerB extends AbstractHander { @Override public void handle(int days) { if(days &lt; 10){ System.out.println(\"**条件符合，由B自己处理这个请求\"); }else{ System.out.println(\"##条件不符合，由B转发这个请求到下一个处理者\"); if(nextHandler != null){ nextHandler.handle(days); } } }}public class HandlerC extends AbstractHander { @Override public void handle(int days) { if(days &lt; 15){ System.out.println(\"**条件符合，由C自己处理这个请求\"); }else{ System.out.println(\"##条件不符合，由C转发这个请求到下一个处理者\"); if(nextHandler != null){ nextHandler.handle(days); } } }} 测试123456789101112131415public static void main(String[] args) { //初始化责任链 HandlerA handlerA = new HandlerA(); HandlerB handlerB = new HandlerB(); HandlerC handlerC = new HandlerC(); handlerA.setNextHandler(handlerB); handlerB.setNextHandler(handlerC); //交给链表表头处理 handlerA.handle(13);}输出##条件不符合，由A转发这个请求到下一个处理者##条件不符合，由B转发这个请求到下一个处理者**条件符合，由C自己处理这个请求","link":"/2018/10/26/设计模式-责任链模式/"},{"title":"设计模式-适配器模式","text":"适配器模式跟代理模式写法上类似。适配器模式做的就是，有一个接口需要实现，但是我们现成的对象都不满足，需要加一层适配器来进行适配。分为对象适配器模式、类适配器模式 对象适配器模式12345public interface Duck { void quack(); // 鸭的呱呱叫 void fly(); // 飞} 12345678910public class Cock { public void gobble() { System.out.println(\"咕咕叫\"); } public void fly() { System.out.println(\"鸡也会飞哦\"); }} 12345678910111213141516171819public class ObjectAdapter implements Duck { private Cock cock; public ObjectAdapter(Cock cock) { this.cock = cock; } @Override public void quack() { cock.gobble(); } @Override public void fly() { cock.fly(); }} 无非是我们需要一只鸭，但是我们只有一只鸡，这个时候就需要定义一个适配器，由这个适配器来充当鸭，但是适配器里面的方法还是由鸡来实现的 类适配器模式1234567public class ClassAdapter extends Cock implements Duck { @Override public void quack() { gobble(); }} 通过继承 适配器自动获得了所需要的大部分方法来实现鸭的方法 与代理模式区别目的不一样，代理模式做的是增强原方法的活；适配器做的是适配的活，为的是提供“把鸡包装成鸭，然后当做鸭来使用”，而鸡和鸭它们之间原本没有继承关系 原文链接 Java 设计模式","link":"/2018/10/19/设计模式-适配器模式/"},{"title":"设计模式-代理模式","text":"代理模式就是不直接对外提供其实现类，而是提供其代理类，隐藏实现类的细节，通常还用于在真实的实现的前后添加一部分逻辑 静态代理目标接口123public interface Subject { void hello();} 委托类1234567public class RealSubject implements Subject { @Override public void hello() { System.out.println(\"hello\"); }} 代理类123456789101112131415161718192021222324//代理类为了和其实现类功能一样，所以也要实现目标接口类public class StaticProxy implements Subject { //代理对象持有委托类的引用 private Subject realSubject; public StaticProxy(Subject realSubject) { this.realSubject = realSubject; } @Override public void hello() { System.out.println(\"静态代理before\"); realSubject.hello(); System.out.println(\"静态代理after\"); } public static void main(String[] args) { Subject subject = new StaticProxy(new RealSubject()); //调用代理类对象方法 subject.hello(); }} 上面这种方式成为静态代理，静态代理的局限在于运行前必须编写好代理类，如果需要被代理多个方法就会有很多冗余代码 动态代理代理类在程序运行时创建的代理方式被成为 动态代理。 也就是说，这种情况下，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类的函数 jdk自带的动态代理 在使用动态代理时，需要定义一个位于代理类与委托类之间的中介类，这个中介类被要求实现InvocationHandler接口由动态代理类委托中间类，中间类持有真正目标类的引用，其实是两层静态代理 12345678910111213141516171819202122232425262728293031323334353637383940414243public class JDKDynamicProxy implements InvocationHandler { //中间类持有真正目标类的引用 private Object subject; public DynamicProxy(Object subject) { this.subject = subject; } /** * 拦截代理类对象的所有方法 * @param proxy 代理类对象 * @param method 具体调用的是代理类的哪个方法 * @param args 方法参数 * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(proxy.getClass().getName()); System.out.println(\"动态代理before\"); method.invoke(subject, args);//执行目标类方法 System.out.println(\"动态代理before\"); return null; } public static void main(String[] args) { //让中间类持有真正目标类的引用 InvocationHandler handler = new JDKDynamicProxy(new RealSubject()); //创建动态代理类实例 Subject subject = (Subject) Proxy.newProxyInstance( Thread.currentThread().getContextClassLoader(),//定义了代理类的ClassLoder new Class[] {Subject.class},//代理类实现的接口列表 handler);//调用处理器 System.out.println(subject.getClass().getName()); //调用代理类实例方法 subject.hello(); } 12345com.sun.proxy.$Proxy0com.sun.proxy.$Proxy0动态代理beforehello动态代理before 特点： 类名：格式是“$ProxyN”，其中 N 是一个逐一递增的阿拉伯数字，代表 Proxy 类第 N 次生成的动态代理类，并不是每次调用 Proxy 的静态方法创建动态代理类都会使得 N 值增加，原因是如果对同一组接口（包括接口排列的顺序相同）试图重复创建动态代理类，它会很聪明地返回先前已经创建好的代理类的类对象，而不会再尝试去创建一个全新的代理类，这样可以节省不必要的代码重复生成，提高了代理类的创建效率 类继承关系：Proxy 类是它的父类，这个规则适用于所有由 Proxy 创建的动态代理类。而且该类还实现了其所代理的一组接口 缺点：Proxy只能对interface进行代理，无法实现对class的动态代理。观察动态生成的代理继承关系图可知原因，他们已经有一个固定的父类叫做Proxy，Java语法限定其不能再继承其他的父类 cglib实现的动态代理CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充 原理：动态生成一个要代理类的子类，子类重写要代理的类的所有不是final的方法。在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。它比使用java反射的JDK动态代理要快。 底层：使用字节码处理框架ASM，来转换字节码并生成新的类。不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。 缺点：对于final方法，无法进行代理 1234567891011121314151617181920212223242526public class CglibDynamicProxy { public static void main(String[] args) { Enhancer enhancer = new Enhancer(); ////设置增强类的父类 enhancer.setSuperclass(RealSubject.class); //设置拦截器，拦截对父类所有非final方法的调用 enhancer.setCallback(new MethodInterceptor() { @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { System.out.println(o.getClass().getName()); System.out.println(\"cglib动态代理before\"); //调用父类方法 methodProxy.invokeSuper(o, objects); System.out.println(\"cglib动态代理after\"); return null; } }); //创建动态代理对象 Subject subject = (Subject) enhancer.create(); System.out.println(subject.getClass().getName()); subject.hello(); }} 12345me.changjie.proxy.RealSubject$$EnhancerByCGLIB$$636b402ame.changjie.proxy.RealSubject$$EnhancerByCGLIB$$636b402acglib动态代理beforehellocglib动态代理after 配合过滤器使用可选择性的对方法进行拦截123456789101112131415161718192021222324252627282930313233343536373839404142public class CglibDynamicProxy2 { public static void main(String[] args) { Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(RealSubject.class); Callback interceptor = new MethodInterceptor() { @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable { System.out.println(o.getClass().getName()); System.out.println(\"cglib动态代理2before\"); //调用父类方法 methodProxy.invokeSuper(o, objects); System.out.println(\"cglib动态代理2after\"); return null; } }; //NoOp表示no operator，即什么操作也不做，代理类直接调用被代理的方法不进行拦截 enhancer.setCallbacks(new Callback[]{interceptor, NoOp.INSTANCE}); CallbackFilter filter = new CallbackFilter() { @Override public int accept(Method method) { if (method.getName().equals(\"hello2\")) { System.out.println(\"我将此方法过滤掉了，不对该方法进行拦截\"); return 1;//对应拦截器数组索引，NoOp.INSTANCE } return 0;//对应拦截器数组索引，interceptor } }; enhancer.setCallbackFilter(filter); RealSubject realSubject = (RealSubject) enhancer.create(); realSubject.hello(); realSubject.hello2(); }} 123456我将此方法过滤掉了，不对该方法进行拦截me.changjie.proxy.RealSubject$$EnhancerByCGLIB$$afdc3840cglib动态代理2beforehellocglib动态代理2afterhello2","link":"/2018/10/19/设计模式-代理模式/"}],"tags":[],"categories":[{"name":"Dubbo","slug":"Dubbo","link":"/categories/Dubbo/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"java基础","slug":"java基础","link":"/categories/java基础/"},{"name":"java集合","slug":"java集合","link":"/categories/java集合/"},{"name":"Mysql","slug":"Mysql","link":"/categories/Mysql/"},{"name":"多线程","slug":"多线程","link":"/categories/多线程/"},{"name":"设计模式","slug":"设计模式","link":"/categories/设计模式/"}]}